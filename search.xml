<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“落子无悔，抉择本身就是向前”——2022年度总结</title>
    <url>/2022/12/29/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h1><p>岁月不居，时节如流。一转眼，2022年已经来到了尾声，这一年里，经历了高考，度过了18岁的生日，踏上了大学的校园，遇见了许许多多的人，也经历了许许多多的事。这一年，对我来说，没有所谓的轰轰烈烈， 也没有所谓的刻骨铭心，吃过很多亏，做过很多傻事，当然，我也收获很多。年末之际，对此做些回顾与梳理，不失为一种享受，也算是对自己的反思总结。</p>
<span id="more"></span>
<h1 id="2、2022回顾与总结"><a href="#2、2022回顾与总结" class="headerlink" title="2、2022回顾与总结"></a>2、2022回顾与总结</h1><h2 id="2-1、新阶段"><a href="#2-1、新阶段" class="headerlink" title="2.1、新阶段"></a>2.1、新阶段</h2><p>9月，踏上了大学的校园，期待与憧憬，想象着我将在这里开始我的很多第一次。上大学前，身边充斥着各种各样的声音，也面临着各种各样的选择，所谓的虚荣？所谓的风光？是随波逐流，还是遵从内心？我，选择了后者。半年过去了，目前来说，我很庆幸当时的抉择。学生嘛，总有那么一点放荡不羁，总有那么一点桀骜不驯，何必那么在意他人的看法，选择适合自己的，就是最好的。我觉得，人总是要和时代挂钩的，总是要有联系的，倘若只闭门造车，也许只会是固步自封，倘若只是看到眼前，也许就会被时代给抛弃。上大学后，大学的生活和我曾经想象的不太一样，选择更多了，机会更多了，当然，挑战也更多了。如何规划自己的学习与生活？如何选择自己要走的道路？如何朝自己的方向努力？这是值得思考的问题。与其自我内耗，不如踏实奋斗，奋斗，仍然是最有意义的答案。<img src="https://s2.loli.net/2023/07/25/UnxACgVXrvRPTLD.jpg" alt="校园"></p>
<h2 id="2-2、学习与收获"><a href="#2-2、学习与收获" class="headerlink" title="2.2、学习与收获"></a>2.2、学习与收获</h2><p>大学的学习，与之前完全不同，变得更自由了，变得更深、更广了。编程的学习，也与其他的学习有所不同，近半年来，我切身地感受到编程的学习不仅要把理论搞懂，更重要的是动手实践，敲代码，解决问题，实践操作，这样学起来更加得舒服，也更扎实。大一上，学习到的知识与内容非常地多，而且非常地杂。但是，重点还是编程能力，数学思维，以及英语素养。高考完的暑假，我自学了C语言的一部分内容，这也让我能在专业课上学的比较舒服。在上了一些专业课与理论课后，我切身地感受到自学的重要性。因此，我开始真正学习到对自己有用的知识。学习，挺枯燥乏味的，但也可以是充满趣味的，通过学习C语言，我可以写出一两个小游戏，利用各种函数还能实现一些创意功能，如用蜂鸣函数，调整频率实现一首歌曲。<br><img src="https://s2.loli.net/2023/07/25/oiQy2I8fcYpTlXA.jpg" alt="教室学习"><br>近朱者赤，近墨者黑。很荣幸，通过iflab的面试，加入了这个大家庭。在社团中，导师们分享学习的经验与技巧，介绍各类比赛与经验，交流行业知识与现状，热心回答我们的疑问。因此，我也学到了很多，我创建了自己Github，有了自己的代码仓库，我也成功搭建部署了自己的个人博客，并且对行业的情况有了自己的认识与了解，通过FCC的学习打卡，对网页，前端内容有了一定的了解……相互学习是能促进进步的，别人有优点，去向他请教学习，何尝不是对自己的一种好处呢？勾心斗角，只会阻碍自己的进步。本学期，虽然离自己的学习目标还差挺大距离，但也收获许多，只能说，继续加油吧。<img src="https://s2.loli.net/2023/07/25/7BuPqwI1Zj69k2Y.jpg" alt="FCC打卡奖品"></p>
<h2 id="2-3、生活态度"><a href="#2-3、生活态度" class="headerlink" title="2.3、生活态度"></a>2.3、生活态度</h2><p>2022年，发生了许多变化，个人在变，社会在变，整个世界都在变。谁能想到，上半年还在高三的教室刷题的我，现在已经开始敲代码了呢？谁能想到，11月还在封控的疫情，12月年末就放开了呢？生活吧，总是会和你开玩笑，你得笑着回应它。不得不说，这一年里，我的人生观，价值观都在悄悄地发生着改变，除了学习呢，我也学会了很东西。这一年的疫情，压得人喘不过气来，有人抱怨，有人吐槽，社会就是如此，有些东西你无法改变，遵从自己的内心，同时做好自己，这不失为一种明智的选择。人，茫茫碌碌，到处奔波，但不应只有工作和学习。校园的健康跑，包括我在内挺多人吐槽的，但是3公里跑步的那些天，让我感觉非常舒服，睡眠质量提高了，学习效率也提升了，整个人的状态也是完全不同的。闲暇之余，我也会拿起吉他，随性弹唱一曲，哼唱两句：“长亭外，古道边，芳草碧连天……”。追逐浮世骄阳，也别错过人间万象。<img src="https://s2.loli.net/2023/07/25/RbGvO54aQ3UTuxD.jpg" alt="日落"></p>
<h1 id="3、展望2023"><a href="#3、展望2023" class="headerlink" title="3、展望2023"></a>3、展望2023</h1><p>2022年，有收获，也有遗憾，那就展望一下2023年<br><br>1.2023年开始持续输出博客，坚持输出达到20篇。<br><br>2.寒假学习数据结构与算法和C++，筑牢基础。<br><br>3.2023年一整年完成计算机四大件的学习，并尝试做一些中大型项目。<br><br>4.拿下四六级，驾驶证，取得3个以上计算机相关的比赛奖项。<br><br>5.阅读更多的书籍，专业书籍，如《C和指针》、《C陷阱与缺陷》、《大话数据结构》等与其他方面书籍。<br><br>6.游历北京城，参加户外实践，参观景点，各种展览，增长见识。<br><br>7.坚持体育锻炼，跑步、骑行、参加一些球类运动。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>悟已往之不谏，知来者之可追。新的一年要来了，过去的就让它过去吧，寒冬过后，都会回暖，2023，我们一起加油呀！新年快乐！</p>
<p><img src="https://s2.loli.net/2023/07/25/mVQKNhn1Zo4pkbY.webp" alt="烟花"></p>
]]></content>
  </entry>
  <entry>
    <title>2023年最后一个月了，当初的愿望实现了吗？</title>
    <url>/2023/11/30/2023%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BA%86%EF%BC%8C%E5%BD%93%E5%88%9D%E7%9A%84%E6%84%BF%E6%9C%9B%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/11/30/R2VHYyZDFcTs4rG.png" alt="当初的愿望实现了吗？">  </p>
<p>不知不觉，2023年只剩下最后一个月了，只能说，时光过得好快！今年是梦幻的一年，好像做了很多事，但也好像没做什么，也许是接触到的东西比之前多了吧，我也体验了很多东西，同时我也切身感受到我的思维、价值观、人生观也一直在潜移默化地改变着。这么说似乎也没错，因为人本来就是一直会变的嘛。今天重新翻看了之前自己写的一些文章，突然看到了年初立下的小目标： </p>
<span id="more"></span>

<hr>
<p><img src="https://s2.loli.net/2023/11/30/OFlHeGy9LTv5CBE.png" alt="朝花夕拾"></p>
<p>也不能说是目标吧，其实也就是自己当时的一些展望，与当时的想法状态关系较大。当时真是想法多啊，别人列个三四条，自己列了六七条，看来当时的我还是有点自信乐观在的，好笑的是第一条目前就没有实现。其实上半年也有写，但是没有把他们写在自己的博客上吧，还剩一个月，想达到20篇估计也不可能了，而且我个人不喜欢强行为了写文章而写文章，我觉得写文章的目的是把自己的想法表现出来，不喜欢“为赋新词强说愁”。虽然这些目标没有完全实现吧，有遗憾和可惜，但也好像大部分也都实现了：</p>
<ul>
<li>今年有持续输出博客，表达自己的想法，记录自己的生活。</li>
<li>寒假的时候也提前学完了常见数据结构和算法，同时也把C++学了一遍，在上半年经过选拔加入了ACM校队，参加了一些网络算法赛，也体会到了AC题目时的快乐。项目是做了几个，但估计都算不上中大型项目，现在想想还是得多积累经验才行，把基础打好也更重要些。</li>
<li>计算机四大件，其实都有了解接触，系统学了三大件，近期期末，可支配的时间也不多，多利用时间学吧。</li>
<li>上半年拿下了四级，暑假一举拿下了驾驶证，12月份考6级，希望能过吧！奖项也有获得些吧，互联网+市赛证书、程序设计竞赛证书、创新杯一等奖等。</li>
<li>读过的书籍：《C++ Prime Plus》、《C++ Prime》、《数据结构与算法C++版》、《鸟哥的Linux私房菜》、《计算机网络–谢希仁版》、《Everyone is PM》、《小王子》、《亲密关系》、《浪潮之巅》等。</li>
<li>去过的景点：故宫、颐和园、什刹海、鼓楼、南锣鼓巷、王府井、清华、北大、北邮、北师大、蟒山等，这些是北京城的；其他城市：上海外滩、杭州西湖、天津之眼、天津东堤公园等。展览实践：北大无人机挑战赛开幕式、国际大学生魔术表演、WWDC之夜北京会场、字节跳动OpenDay等。</li>
<li>有在坚持运动、校园6公里马拉松、乒乓球、每学期42天的三公里跑等</li>
</ul>
<p>有点不可思议，好像还是实现得挺多的，虽然这些目标不是什么很伟大的吧，但是当你回头再看的时候，好像自己真的完成了这样的一个个小目标，原来自己真的也挺棒的！说实话，今年做过的、体验过东西的远比这些所列目标多得多，而这些目标其实也只是自己的一点展望，我认为人不应该被这些所谓立下的flag而倍感压力导致困顿，而是以此为动力鞭笞自己向前，这应该是一种激励作用，而不是什么负担。现在回过头来看，其实自己也没有能完全实现这些‘目标’嘛，但是又何妨呢？要是都能完全实现的话，那我就马上立个超大超梦幻的flag！</p>
<hr>
<p>哈哈，用心去做自己喜欢的，热爱的，并坚持下去就好啦，这不还剩一个月嘛，“莫道桑榆晚，为霞尚满天。”，好好珍惜喽！</p>
]]></content>
  </entry>
  <entry>
    <title>QT报错：ERROR: Unknown module(s) in QT: core5compat</title>
    <url>/2024/01/31/QT%E6%8A%A5%E9%94%99%EF%BC%9AERROR-Unknown-module-s-in-QT-core5compat/</url>
    <content><![CDATA[<h1 id="Qt报错：error-Project-ERROR-Unknown-module-s-in-QT-core5compat"><a href="#Qt报错：error-Project-ERROR-Unknown-module-s-in-QT-core5compat" class="headerlink" title="Qt报错：error: Project ERROR: Unknown module(s) in QT: core5compat"></a>Qt报错：error: Project ERROR: Unknown module(s) in QT: core5compat</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天在github上下载了一些项目源码进行学习，但是当我用自己的QT Creator进行构建编译时，出现了报错：<br><img src="https://s2.loli.net/2024/01/31/gtyOW2aksq9dZzp.png" alt="显示灰色.png"><br><img src="https://s2.loli.net/2024/01/31/BURAG4cM17JVlsu.png" alt="报错信息.png">  </p>
<span id="more"></span>  
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据报错信息，显示不知道的模块：core5compat，应该是自己的QT中缺少了环境名为：core5compat的模块。<br>经过查询后得知，自己的Qt版本是Qt 6，是Qt框架的最新主要版本，相比于Qt 5，它提供了许多改进和新特性，但也移除了一些旧特性和类。core5compat 模块：为了帮助开发者从Qt 5迁移到Qt 6，Qt 6提供了一个名为 core5compat 的兼容性模块。这个模块包含了一些在Qt 6中被弃用但在Qt 5中常用的类和方法。错误消息 “Unknown module(s) in QT: core5compat” 指的是在尝试编译或运行一个使用Qt框架的项目时，Qt环境中缺少名为 core5compat 的模块。这通常出现在尝试将基于Qt 5的代码迁移到Qt 6时，因为Qt 6中移除或更改了一些在Qt 5中存在的功能。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>首先检查自己项目构建时用的QT版本，一般在打开.pro文件时即可选择，<strong>如下图，我这里是用的Qt6.2.4，项目版本得看这个，不要看help中的about，那个不一定是本项目所用的</strong><br><img src="https://s2.loli.net/2024/01/31/xryFA9zZMjwTJ2R.png" alt="项目构建版本.png"></li>
<li>接着打开并运行<strong>Qt Maintenance Tool。通常可以在安装Qt的文件夹中找到它</strong>，在Qt Maintenance Tool中，执行以下操作：</li>
</ul>
<ol>
<li>选择“添加或删除组件”（Add or Remove Components）。</li>
<li>展开已安装的Qt版本，例如我这的 Qt 6.2.4。</li>
<li>寻找名为“Qt 5 Compatibility Module”或类似名称的组件，它就是 core5compat 模块。</li>
<li>选中该组件，然后点击“下一步”（Next）来开始安装。</li>
<li>等待安装完成后，关闭Qt Maintenance Tool。<br><img src="https://s2.loli.net/2024/01/31/EFicJb4kaUw7DpL.png" alt="Qt Maintenance Tool.png"></li>
</ol>
<ul>
<li><p>然后更新项目文件，打开项目文件（通常是一个以 .pro 结尾的文件），并确保包含了core5compat模块。<strong>如果文件中没有“QT +&#x3D; core5compat”这行代码的话，还需要在.pro文件中添加：<br>QT +&#x3D; core5compat，这会告诉Qt构建系统您的项目依赖于core5compat模块。</strong></p>
</li>
<li><p>最后重新打开并编译项目，可以clean然后rebuild，即可正常运行<br><img src="https://s2.loli.net/2024/01/31/CwOEmnJkSBILR6y.png" alt="成功运行.png"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>STL--vector容器(构造、遍历、插入删除、容量大小、数据存取、动态扩容等)</title>
    <url>/2023/11/11/STL-vector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天在写代码的时候用到STL较多，也感受到了STL的强大，于是我重新温习了一遍STL的内容，并把一些基础的东西，重要的内容总结提炼出来，这篇是vector篇。C++的STL给我们提供了很多可用的容器，vector就是最常用的容器之一,vector应该掌握的基础内容包括构造函数、元素的插入插入删除、赋值、存取等操作。重点内容应该掌握vector的扩容机制、内存大小的变化原理等。</p>
<span id="more"></span>  
<h2 id="1、vector简介"><a href="#1、vector简介" class="headerlink" title="1、vector简介"></a>1、vector简介</h2><ul>
<li>vector容器为可变长数组（动态数组），可以随时插入删除元素。</li>
<li>vector被称为向量容器，因为该容器擅长在尾部插入或删除元素， 在O（1）时间就能够完成;而如果要在容器头部或者中间插入数组元素，则需花费O（N）的时间，因为他需要将后面的元素往后移。（其实原理也就类似于我们在数据结构与算法中学的顺序表）</li>
<li>vector与普通数组大的区别在于：数组是静态数组（容量固定的数组），而vector可以动态拓展。即可以进行容器的插入和删除，这个过程中，vector会动态调整所占用的空间。</li>
<li>vector访问元素也同样要遵守不能越界的规则，否则会造成内存的安全隐患。</li>
</ul>
<h2 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h2><p>(1)功能：用来创建vector容器<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> vector&lt;T&gt; v;<span class="comment">//默认无参构造</span></span><br><span class="line"><span class="number">2.</span> vector&lt;T&gt; v&#123;elem1, elem2, elem3 ...&#125;<span class="comment">//指定元素构造</span></span><br><span class="line"><span class="number">3.</span> <span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(n, elem)</span><span class="comment">//将n个elem拷贝为元素构造</span></span></span><br><span class="line"><span class="function">4. vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span><span class="comment">//拷贝另一个vector构造</span></span></span><br><span class="line"><span class="function">5. vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span><span class="comment">//区间构造，将v1区间的begin()到end()的元素赋值给v2；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//二维构造初始化</span></span></span><br><span class="line"><span class="function">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));<span class="comment">//二维构造</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector容器构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">11</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/mfyTFxLJAtRb153.png" alt="vector容器构造.png">  </p>
<h2 id="3、赋值操作"><a href="#3、赋值操作" class="headerlink" title="3、赋值操作"></a>3、赋值操作</h2><p>(1)功能：给vector容器赋值<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> vector&amp; <span class="keyword">operator</span> = (<span class="type">const</span> vector &amp;vec);<span class="comment">//重载等号运算符</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>())用assign来区间赋值</span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">assign</span>(n, elem)，将n个elem拷贝赋值给元素</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/dRQ9XNxUPz4Gke1.png" alt="vector赋值操作.png"></p>
<h2 id="4、容量和大小"><a href="#4、容量和大小" class="headerlink" title="4、容量和大小"></a>4、容量和大小</h2><p>(1)功能：对vector容器进行容量和大小的操作<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> v.<span class="built_in">empty</span>();<span class="comment">//用来判空</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">capacity</span>();<span class="comment">//用来获取容器中元素个数的大小</span></span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">size</span>();<span class="comment">//用来获取容器当前元素个数</span></span><br><span class="line"><span class="number">4.</span> v.<span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//用来重新指定容器的长度,如果变短则阶段删除</span></span><br><span class="line"><span class="number">5.</span> v.<span class="built_in">resize</span>(<span class="type">int</span> num, <span class="type">int</span> elem);<span class="comment">//用来重新指定容器的长度，并以elem来填充</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量、大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;capacity容量：&quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的大小为：&quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新指定大小</span></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">14</span>);  <span class="comment">//如果重新指定的比原来长了，默认用0填充新的位置</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">11</span>, <span class="number">45</span>);  <span class="comment">//重载，参数2可以指定默认填充值</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">4</span>);  <span class="comment">//如果重新指定的比原来短了，超出的部分会被截断</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/asJfFOLiZrRQhkb.png" alt="vector容量和大小.png"></p>
<p><strong>补充：</strong>  </p>
<ul>
<li>vector中的capacity指的是容量，即在不分配更多内存的情况下，可以保存的最多个数，而size则是当前容器的大小。</li>
<li><strong>size 总是小于或等于 capacity</strong></li>
<li>当容器中的size &#x3D;&#x3D; capacity时,此时再向其中插入内容的话，则vector会申请出更多的空间。</li>
<li><strong>申请空间时不是直接在原来的空间上连续往下开辟，而是另找一块更大的空间，完成拷贝操作后，然后把当前vector的指针指向新的更大的空间。</strong></li>
</ul>
<h2 id="5、插入和删除"><a href="#5、插入和删除" class="headerlink" title="5、插入和删除"></a>5、插入和删除</h2><p>(1)功能：往vector容器中插入和删除元素<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> v.<span class="built_in">push_back</span>(ele);<span class="comment">//尾插元素</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">insert</span>(const_iterator pos, ele);<span class="comment">//在迭代器指向位置pos处插入元素ele</span></span><br><span class="line"><span class="number">4.</span> v.<span class="built_in">insert</span>(const_iterator  pos, count, ele);<span class="comment">//在指定位置pos插入count个元素</span></span><br><span class="line"><span class="number">5.</span> v.<span class="built_in">erase</span>(const_iterator  pos);<span class="comment">//删除迭代器指向位置的元素</span></span><br><span class="line"><span class="number">6.</span> v.<span class="built_in">erase</span>(const_iterator  start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="number">7.</span> v.<span class="built_in">clear</span>();<span class="comment">//删除容器中所有的元素</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">14</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    v1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">114</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定位置指定数量插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">514</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除区间</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2清空前：&quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    v2.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2清空后: &quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/XaELBwfKrmn6s4p.png" alt="vector插入和删除.png"></p>
<h2 id="6、数据存取操作"><a href="#6、数据存取操作" class="headerlink" title="6、数据存取操作"></a>6、数据存取操作</h2><p>(1)功能：对vector中的数据进行存储和拿取操作。<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">operator</span>[index];<span class="comment">//类似数组中的[]，返回索引index所指向的数据</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">at</span>(<span class="type">int</span> index);<span class="comment">//用at函数来返回索引index所指向的数据</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">front</span>();<span class="comment">//返回容器中的第一个数据</span></span><br><span class="line"><span class="number">4.</span> <span class="built_in">back</span>();<span class="comment">//返回容器中最后一个元素</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用[]的方式访问数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用at的方式访问数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素为：&quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最后一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/HiO7dISFB4WbkVj.png" alt="vector数据存取.png"></p>
<h2 id="7、互换容器"><a href="#7、互换容器" class="headerlink" title="7、互换容器"></a>7、互换容器</h2><p>(1)功能：将两个容器的元素进行交换<br>(2)方式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">swap</span>(v2);<span class="comment">//将v2的元素与v1元素互换</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test06</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/zQwTGWjLyrKCdqk.png" alt="vector互换容器.png"></p>
<p><strong>补充（重要用途）：</strong><br>我们可以使用swap来使两个容器互换，加之匿名对象的性质，可以用来达到<strong>收缩内存空间</strong>的目的。方式如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果单重新指定大小的话，容量并没有变,导致多余的空间浪费</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">25</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用resize(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//而我们可以巧用swap()来收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">//vector&lt;int&gt;(v)创建了一个匿名对象，会按照v大的大小初始化这个匿名对象容器的大小</span></span><br><span class="line">                                  <span class="comment">//用swap()会将其与匿名函数进行交换，原容器的指针指向匿名对象的容器，原指向匿名对象容器的指针指向原容器</span></span><br><span class="line">                                  <span class="comment">//系统创建完匿名函数后会对匿名对象的指针（地址、内存）进行回收</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用swap+匿名函数: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test07</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/6zufVWerAqth4LZ.png" alt="vector收缩内存空间.png"></p>
<h2 id="8、预留空间"><a href="#8、预留空间" class="headerlink" title="8、预留空间"></a>8、预留空间</h2><p>（1）功能：预先开辟空间，减少vector在动态扩展容量时的扩展次数。<br>（2）方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度,预留位置不初始化,元素不可访问</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每扩容一次就会新开一块内存，则p指向的地址与原来的不同，以此来统计动态开辟的次数。</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != &amp;v1[<span class="number">0</span>]) &#123;</span><br><span class="line">            p1 = &amp;v1[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不预留空间时count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">114514</span>);</span><br><span class="line">    <span class="type">int</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (p2 != &amp;v2[<span class="number">0</span>]) &#123;</span><br><span class="line">            p2 = &amp;v2[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;预留空间时count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test08</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/ypYEBs6Q4ITXuJw.png" alt="vector预留空间.png"></p>
<h2 id="vector小结"><a href="#vector小结" class="headerlink" title="vector小结"></a>vector小结</h2><ul>
<li>vector容器是最常用的容器之一，大多时候需要用它来存储数据。</li>
<li>构造函数，元素访问，二维容器，遍历获取，插入删除等操作比较常见。</li>
<li>基础常用的是用[]来获取，访问，构造匿名构造和指定大小构造用得较多，push_back()也用的较多。</li>
<li>注意迭代器的访问，因为它能直接指向内存，且较灵活。</li>
<li>构造、赋值操作中的内存原理需要掌握，扩容时机制是重新开一块新的空间，指针重新指向。</li>
<li>匿名对象的地址、内存会被系统自动回收，因此可以巧用swap和匿名对象来收缩空间，另外注意一下预留空间能减少动态扩容开辟次数。</li>
</ul>
<blockquote>
<p>以上就是关于vector容器常见操作和原理的全部内容了，如果文章有什么错误或者遇到什么问题，欢迎随时和我交流联系。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>first</title>
    <url>/2022/10/09/first/</url>
    <content><![CDATA[<p>不要强求不可知，要从已知推未知。</p>
]]></content>
  </entry>
  <entry>
    <title>photos</title>
    <url>/2022/10/15/photos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/11/04/test/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/07/10/fyHQn2XGReotmVg.jpg" alt="阿狸的世界.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/10/13/title/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vscode写markdown文件中的tab缩进错误显示问题</title>
    <url>/2023/11/13/vscode%E5%86%99markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84tab%E7%BC%A9%E8%BF%9B%E9%94%99%E8%AF%AF%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="用vscode写Markdown时tab键在网页上缩进错误问题"><a href="#用vscode写Markdown时tab键在网页上缩进错误问题" class="headerlink" title="用vscode写Markdown时tab键在网页上缩进错误问题"></a>用vscode写Markdown时tab键在网页上缩进错误问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>这两天在写博客时，遇到了一个奇怪的错误，就是在博客上传到网站上预览时，代码块中用tab键缩进的空格变成了8空格。我平时用vscode来编写博客，在本地渲染预览时没有问题，显示为4个空格，然而传到博客网站上时就变成8空格，有些奇怪。</strong>  </p>
<p>博客网站上显示：  </p>
<p><img src="https://s2.loli.net/2023/11/13/kj9Obl71K4of2Ct.png" alt="缩进问题.png"> </p>
<span id="more"></span>  
<p>本地预览：  </p>
<p><img src="https://s2.loli.net/2023/11/13/lxBeuiwbzEYpC5h.png" alt="本地预览.png"> </p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我一开始以为是我的tab-size设置有误，于是我检查了我的tab-size设置，发现并无问题，就是4个空格。<br><img src="https://s2.loli.net/2023/11/13/hgABoUy6LCNMt9W.png" alt="tab-size.png"> </p>
<p>后来我想起之前在编辑微信公众号时使用的秀米排版编辑器遇到的问题，当时首行缩进不能直接用空格，否则会导致排版错误。于是我又检查了是否是因为自己误用空格或空行导致一些格式错误、渲染错误啥的，重新检查打了一遍后，发现网站上显示还是又有问题，看来并不是空格空行导致的。  </p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终通过查阅资料，解决了这个问题。<br>解决方案如下：  </p>
<ul>
<li>首先打开vscode的命令窗口（在vscode中用快捷键<strong>ctrl + shift + p</strong>）</li>
<li>然后在命令窗口输入convert，会自动弹出下面这两个命令，我们选择<strong>Convert Indentation to Spaces</strong>将tab缩进转为空格命令。</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/13/R1E8nv6CIQuM37Y.png" alt="tab缩进转为空格.png"></p>
<ul>
<li>然后我们在去博客网站上预览，发现成功变回4空格。</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/13/QuPMOV54kwLiB6p.png" alt="tab问题解决后.png">  </p>
<blockquote>
<p>以上问题就成功解决了，成功上传显示无问题后还是挺开心的。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>如何将两个很大的数进行相加？</title>
    <url>/2023/10/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AE%97%E6%B3%95%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="经典大数相加算法、高精度加法"><a href="#经典大数相加算法、高精度加法" class="headerlink" title="经典大数相加算法、高精度加法"></a>经典大数相加算法、高精度加法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>先上一道题</strong>：<a href="https://leetcode.cn/problems/add-strings/"><strong>LC415.字符串相加</strong></a>     </p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<hr>
<p>对于这道题，可能很多朋友会想到将两个字符转为数字，然后将其进行相加，最后将结果再转为字符串。这种方式可行，但是如果数字非常大呢？大到连long long 都不够加呢?那我们就得请出我们的主角：<strong>高精度加法</strong>。  </p>
<span id="more"></span>
<h2 id="高精度加法是什么？"><a href="#高精度加法是什么？" class="headerlink" title="高精度加法是什么？"></a>高精度加法是什么？</h2><p>百科上的定义：高精度加法是信息学的一种重要算法。这种算法使用多个存储单位进行计算，因此它的计算范围超过一般使用一个存储单位的算法。所谓高精度加法，其实就是<strong>竖式加法</strong>，竖式加法我们在小学2年半的时候都学过，例如我要实现114 + 514，那就是：<br><img src="https://s2.loli.net/2023/10/18/2DF5GTCgQUMhOHW.png" alt="竖式加法.jpg">   </p>
<p>如上图所示，我们从个位开始相加，4 + 4 &#x3D; 8，然后到十位，1 + 1 &#x3D; 2，接着到百位，1 + 5 &#x3D; 6，所得结果就是628。所示例子没有进位，如果有进位的话，需要加上进位值。如9 + 3，需要进1，本位是2。</p>
<h2 id="为什么需要高精度加法？"><a href="#为什么需要高精度加法？" class="headerlink" title="为什么需要高精度加法？"></a>为什么需要高精度加法？</h2><p>高精度加法原来就是所谓的竖式相加，这不是小学生都会吗？其实，高精度加法在计算机算法中有着重要的应用。我们知道,在C&#x2F;C++语言中，通常来说（32位机器）,<strong>int、long类型占32位，long long类型占64位，而最大的类型unsigned long long能表示的最大数也就才(1e19+8e18)</strong> ，如果要几百位的数来进行相加，那就不行了，所以，我们就可以使用高精度来计算，高精度一般也会用来处理大数相加的问题。</p>
<h2 id="高精度加法实现（C-）"><a href="#高精度加法实现（C-）" class="headerlink" title="高精度加法实现（C++）"></a>高精度加法实现（C++）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们将两个大数采用字符串的形式输入，然后模拟竖式加法的过程，<strong>用两个指针，先从个位开始相加（即字符串的最后一位），我们定义一个变量add来存进位值（如果没有进位则为0），然后逐步往高位移动，继续相加。考虑到两个数位数会有不一样的情况，有一个先加完，一个后加完，那我们采取将先加完的数的剩余位默认补0的方式即可</strong>，具体代码实现如下。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从个位开始相加，初始化进位add为0</span></span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;<span class="comment">//定义一个空字符串来拼接答案</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当其中一个数没加完或者进位大于0时执行循环</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//当前位数没有加完则为本身，加完的话则默认为补的0</span></span><br><span class="line">            <span class="type">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> result = x + y + add;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前位的值加入ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新进位值</span></span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由于每一位插入时是尾插导致低位在前，翻转一下即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max(len1, len2))，其中len1和len2分别为两字符串的长度。  </li>
<li>空间复杂度：O(1)，我们只需要常数空间来存储若干变量。</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/add-binary/"><strong>LC67.二进制求和</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/"><strong>LC2.两数相加</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/"><strong>LC445.两数相加II</strong></a>    </p>
<hr>
<p>这里我们研究一下两数相加这题，题目如下：  </p>
<p><strong>LC2.两数相加</strong><br>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><img src="https://s2.loli.net/2023/10/18/OfD6LoA2caST81m.png" alt="add-two.png"></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果仔细看完高精度加法的内容的话，会发现，这也不还是相当于模拟加法的过程吗?只是存储形式从字符串变为了链表而已。我们先<strong>把两链表头看成最低位即个位，开始进行相加，同样我们也用一个变量add来存储进位值，接着进行下一个节点的相加，一直到链表为空,同样也是会有一个链表先走完的情况，那我们将先走完的剩下的空位补0即可</strong>。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建头指针和尾指针</span></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义变量表示进位值，初始化为0</span></span><br><span class="line">        <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//当其中一个链表不为空时或者进位值不为0时进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || add &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + add;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个节点来存储相加后当前位的值</span></span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">                head = tail = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail -&gt; next = tmp;</span><br><span class="line">                tail = tail -&gt; next;<span class="comment">//更新tail</span></span><br><span class="line">            &#125;</span><br><span class="line">            add = sum / <span class="number">10</span>;<span class="comment">//更新进位值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//迭代往下走</span></span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><p>我们在上面入门学习了高精度加法，即模拟竖式计算，也通过字符串相加，两数相加等题目对其有了更深的理解。那其实，有<strong>高精度加法，当然也有高精度减法、高精度乘法、高精度除法</strong>，其实本质上都是在模拟我们竖式计算的过程。而这些高精度计算的方法，为我们计算大数提供了可行方式，今后我们也会逐渐地深入学习和了解。</p>
<blockquote>
<p>以上就是字符串相加、经典大数相加算法(高精度加法)入门的全部内容了，如果文章有什问题或者错误，或者有什么建议和想法，欢迎随时和我交流。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>试</title>
    <url>/2022/10/15/%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>]]></content>
  </entry>
  <entry>
    <title>数据结构——堆（向上调整法/向下调整法、建堆、堆排序、TopK问题）</title>
    <url>/2023/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%A0%86%EF%BC%88%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E6%B3%95-%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E6%B3%95%E3%80%81%E5%BB%BA%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81TopK%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="一、堆的基本概念和性质"><a href="#一、堆的基本概念和性质" class="headerlink" title="一、堆的基本概念和性质"></a>一、堆的基本概念和性质</h2><p>堆(heap)是一个<strong>完全二叉树</strong>，并且满足以下性质：<strong>每个节点的值都大于或等于其左右孩子节点的值，称为大根堆；或是每个节点的值都小于或等于其左右孩子的值，称为小根堆。</strong>  </p>
<p>复习：<span style="background-color: yellow;">完全二叉树</span><br>设二叉树的深度为h，除第h层外，其它各层（1 ~ h-1）的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。  </p>
<p>完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/gay81A3SlPc7Ndu.png" alt="完全二叉树.png"></p>
<span id="more"></span>  
<p>非完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/fmoSUkZwAWRg37q.png" alt="非完全二叉树.png"><br>堆：<br><img src="https://s2.loli.net/2023/10/07/hdSCfPibUsvIuBJ.png" alt="堆.png"><br><strong>从堆的概念不难看出，大根堆堆顶为集合的最大值，小根堆堆顶为集合的最小值</strong>  </p>
<p>  <strong>堆的存储</strong><br>  那么在数据结构中，我们如何存储堆呢？由于堆是一个完全二叉树，这就决定了每个节点的相对位置是固定的，所以这里我们不同于以往的用链表来存储，我们采用一种<span style="background-color: yellow;">船新的存储方式：用一个一维数组来存储堆</span>。为了方便操作，我们采用下标从1开始，<strong>下标1的位置就是根节点，节点x的左儿子是2x,节点x的右儿子是2x + 1</strong><br> <img src="https://s2.loli.net/2023/10/07/k3CJw2iUjxZs4hE.png" alt="堆的存储.png"></p>
<h2 id="二、堆的两个基本操作（down、up）"><a href="#二、堆的两个基本操作（down、up）" class="headerlink" title="二、堆的两个基本操作（down、up）"></a>二、堆的两个基本操作（down、up）</h2><h3 id="1、向上调整法"><a href="#1、向上调整法" class="headerlink" title="1、向上调整法"></a>1、向上调整法</h3><p>向上调整法用于除最后一个元素意外，其余节点均满足堆的性质时，我们用向上调整法将最后一个节点调整成堆。具体做法如下（以小跟堆为例）：<br><strong>从最后一个节点开始，比较该节点和其父节点的大小，如果该节点的值小于父节点的值，则进行交换。一直到该节点到堆顶或者该节点的值大于等于父节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/yMtiC7u8UkjVbrf.png" alt="向上调整法.png">  </p>
<p>那么，具体代码该如何实现呢？我们知道了从父亲推出左右儿子的关系为x &#x3D; 2x 和 x &#x3D; 2x + 1，那知道当前节点的下标，可以反推其父亲节点的下标。假设该节点下标为u，则其父亲节点下标为u &#x2F; 2或者是(u - 1) &#x2F; 2，那经过向下取整的规则后，其父节点下标可以直接写为u &#x2F; 2,那我们就可以写出代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h[]为堆（数组）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u &gt; <span class="number">1</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]&gt;)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[u / <span class="number">2</span>]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、向下调整法"><a href="#2、向下调整法" class="headerlink" title="2、向下调整法"></a>2、向下调整法</h3><p>向下调整法是从上向下调，该方法在建堆，解决排序等问题上有重大作用，所以应当重点掌握。对于采用向下调整法来说，应该满足条件：该根节点左右子树均为大堆或者均为小堆，只有根节点不满足，这时候我们采用向下调整法来将整个树调整成堆。具体做法如下（以小根堆为例）：<br><strong>从根节点开始，比较该节点与其左右孩子节点的值，如果该节点的值大于孩子节点的值，将其与左右孩子中较小的那个进行交换，一直到该节点为最后一层或者该节点的值小于等于左右孩子节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/25mYzOR7TAHBbrD.png" alt="向下调整法.png"></p>
<p>代码实现思路：从根节点，左右孩子节点中比较出最大的那个，如果最大的那个节点是孩子节点，则将根节点与孩子节点进行交换，假设根节点小标为u，则左孩子节点下标为2u,右孩子节点下标为2u + 1,假设节点数为my_size，则代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个变量t来表示最大值下标</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有左孩子，并且左孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有右孩子，并且右孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、堆的一些操作"><a href="#三、堆的一些操作" class="headerlink" title="三、堆的一些操作"></a>三、堆的一些操作</h2><p><strong>1、插入一个数</strong><br>该操作其实就是向上调整法的应用，将该数插入到数组末尾，然后进行向上调整操作即可。  </p>
<blockquote>
<p>heap[my_size++] &#x3D; x; up(my_size);  </p>
</blockquote>
<p><strong>2、求集合当中的最值</strong><br>直接返回堆顶元素即可。</p>
<blockquote>
<p>return h[1];  </p>
</blockquote>
<p><strong>3、删除集合中的最值</strong><br>删除集合中的最值我们采用覆盖的方法，即将最后一个节点的值覆盖到根节点的值，再将my_size–,然后对新的根节点进行向下调整操作即可。为什么要这么做呢？<strong>因为我们使用数组储存的堆结构，而删除第一个元素的话，后面的元素都会进行改变且结构被破坏，比较麻烦。而如果我们用最后一个元素去覆盖的话，前面的其他元素不需要进行改变且维持原有堆结构保持不变（除了新覆盖的根节点不满足），我们只需要将根节点down()操作一下即可，非常方便。</strong><br><img src="https://s2.loli.net/2023/10/07/WVLJAjKUk6vMzql.png" alt="删除集合中的最值.png"></p>
<blockquote>
<p>heap[1] &#x3D; heap[my_size–]; down(1);  </p>
</blockquote>
<p><strong>4、删除任意一个元素</strong><br>删除任意一个元素，假设删除第k个元素，则需要将末尾元素覆盖第k个元素，然后将,my_size–，然后得分情况（以小跟堆为例），如果是变大的话，需要down()一下，如果是是变小的话，需要down()一下，这里我们直接将两个都写，因为这里两个中只会执行一个。</p>
<blockquote>
<p>heap[k] &#x3D; heap[my_size–]; up(k); down(k);  </p>
</blockquote>
<p><strong>5、修改任意一个元素</strong><br>修改任意一个元素与前面同理。</p>
<blockquote>
<p>heap[k] &#x3D; x; down(k); up(k);</p>
</blockquote>
<h2 id="四、堆排序、TopK问题"><a href="#四、堆排序、TopK问题" class="headerlink" title="四、堆排序、TopK问题"></a>四、堆排序、TopK问题</h2><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>知道了堆的基本性质和操作，那给定一个无序数组如何将其建成大堆呢？我们可以用向上调整法和向下调整法。这里我们采用<strong>向下调整法建堆，因为其时间复杂度优于一个一个插入的向上调整法（时间复杂度为O（NlogN）。用向下调整法建堆的时间复杂度为O（N）</strong>，具体建堆过程分析如下：<br>我们从最后一个非叶子结点开始递归向上进行down操作（叶结点自然不用调整），假设总共有n个节点,则最后一个非叶子节点下标为n &#x2F; 2，则我们从n &#x2F; 2处开始进行向下调整即可。<br><img src="https://s2.loli.net/2023/10/07/8IicoWXypqMbSrx.png" alt="建堆过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向下调整时间复杂度分析</strong>：<br>假设右n个节点，从倒数第二层开始，该层有n&#x2F;4个节点，每个节点需要调一次，倒数第三层，该层有n&#x2F;8个节点，每个节点需要调两次,依次类推，时间复杂度为：</p>
<blockquote>
<p>n&#x2F;4 * 1 + n&#x2F;8 * 2 + n&#x2F;16 * 3 + n&#x2F;32 * 4 +…<br>&#x3D; n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …)<br>令S &#x3D; 1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^5 + …<br>则2S &#x3D; 1&#x2F;2 + 2&#x2F;2^2 + 3&#x2F;2^3 + 4&#x2F;2^4 + …<br>2S - S &#x3D; S &#x3D;1&#x2F;2 + 2&#x2F;2^2 + 1&#x2F;2^3 + 1&#x2F;2^4 + … &lt; 1<br>则n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …) &lt; n</p>
</blockquote>
<p>故时间复杂度小于N,进一步分析可知<strong>向下调整建堆的时间复杂度为O（N）</strong></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们来利用堆的性质来进行排序。如果要排升序或者降序，我们应该建大堆还是小堆呢？答案是<strong>排升序，建大堆；排降序，建小堆</strong>。原因是我们要在原数组上进行排序的话，以排升序为例，我们假如建小堆，那么每次的根节点将是当前最小值，而下一步的话最小值根节点为左孩子或者右孩子，这样继续排下去的话，整个堆的结构会被打乱，无法满足要求。而我们采用前面删除的思想，建大堆。每次只需将堆顶和堆底元素进行交换，然后对堆顶进行向下调整，每次都能将最大值放入后面正确的位置，且前面的堆结构维持不变。具体过程如下：<br><img src="https://s2.loli.net/2023/10/07/sL8AXGUB1kViafF.png" alt="堆排序过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(my_size &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[<span class="number">1</span>], h[my_size--]);</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序时间复杂度：向下调整N次，每次调整为O(logN),建堆为O(N)，则为O(N + NlogN),即为O(NlogN);</strong></p>
<h3 id="Topk问题"><a href="#Topk问题" class="headerlink" title="Topk问题"></a>Topk问题</h3><p>接下来我们来看一个经典问题：<span style="background-color: yellow;">Topk问题</span></p>
<p><strong>题目：输入一个长度为 n的整数数列，从小到大输出前 m小的数。</strong><br>此题我们可以用快排等排序来做，  今天我们用堆来做（堆在处理海量数据时具有重要应用）<br>思路：题目要求我们从小到大输出前m小的数,那么我们可以构造一个小根堆，每次取出堆顶元素即可。具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], MySize;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用t来表示三个点里最小值的编号</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有左孩子，并且左孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有右孩子，并且右孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t= <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    MySize = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从n / 2，即最后一个孩子的父亲开始调。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        h[<span class="number">1</span>] = h[MySize--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>本篇文章主要介绍了堆的基本概念和性质</li>
<li>重点介绍了堆的两个基本操作：<strong>向上调整法(up)和向下调整法(down)</strong> ，向下调整法的应用较多，应当重点掌握。</li>
<li>接着我们介绍了基于up和down两种操作的一些堆能实现的操作，<strong>插入一个数、求集合中的最值、删除集合中的最值、删除任意一个元素、修改任意一个元素</strong> ，以及删除时的覆盖思想。</li>
<li>重点分析了建堆的过程：<strong>堆排序和Topk问题</strong>，了解了建堆的方法以及时间复杂度，<strong>一个一个元素插入+向上调整法建堆的时间复杂度是O(N*longN),而从最后一个非叶子节点开始递归向上进行向下调整法建堆的时间复杂度为O(N)</strong> 。</li>
<li>了解了堆的应用，堆排序、Topk问题，知道<strong>排升序，建大堆；排降序，建小堆</strong>。堆在Topk问题上重要应用，我们只需要关注前k个数。堆还有很多重要作用，海量数据时Topk的问题，外排序等内容。</li>
<li><span style="background-color: yellow;">一个元素要成为Topk，经历的过程可不简单，那么我们何尝不是如此？所以，加油吧，朋友。</span><blockquote>
<p>以上就是关于堆的入门的全部内容了，如果文章有什么错误或者遇到什么问题，欢迎随时和我交流联系。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/08/test/test/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>

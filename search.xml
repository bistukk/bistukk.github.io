<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“落子无悔，抉择本身就是向前”——2022年度总结</title>
    <url>/2022/12/29/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h1><p>岁月不居，时节如流。一转眼，2022年已经来到了尾声，这一年里，经历了高考，度过了18岁的生日，踏上了大学的校园，遇见了许许多多的人，也经历了许许多多的事。这一年，对我来说，没有所谓的轰轰烈烈， 也没有所谓的刻骨铭心，吃过很多亏，做过很多傻事，当然，我也收获很多。年末之际，对此做些回顾与梳理，不失为一种享受，也算是对自己的反思总结。</p>
<span id="more"></span>
<h1 id="2、2022回顾与总结"><a href="#2、2022回顾与总结" class="headerlink" title="2、2022回顾与总结"></a>2、2022回顾与总结</h1><h2 id="2-1、新阶段"><a href="#2-1、新阶段" class="headerlink" title="2.1、新阶段"></a>2.1、新阶段</h2><p>9月，踏上了大学的校园，期待与憧憬，想象着我将在这里开始我的很多第一次。上大学前，身边充斥着各种各样的声音，也面临着各种各样的选择，所谓的虚荣？所谓的风光？是随波逐流，还是遵从内心？我，选择了后者。半年过去了，目前来说，我很庆幸当时的抉择。学生嘛，总有那么一点放荡不羁，总有那么一点桀骜不驯，何必那么在意他人的看法，选择适合自己的，就是最好的。我觉得，人总是要和时代挂钩的，总是要有联系的，倘若只闭门造车，也许只会是固步自封，倘若只是看到眼前，也许就会被时代给抛弃。上大学后，大学的生活和我曾经想象的不太一样，选择更多了，机会更多了，当然，挑战也更多了。如何规划自己的学习与生活？如何选择自己要走的道路？如何朝自己的方向努力？这是值得思考的问题。与其自我内耗，不如踏实奋斗，奋斗，仍然是最有意义的答案。<img src="https://s2.loli.net/2023/07/25/UnxACgVXrvRPTLD.jpg" alt="校园"></p>
<h2 id="2-2、学习与收获"><a href="#2-2、学习与收获" class="headerlink" title="2.2、学习与收获"></a>2.2、学习与收获</h2><p>大学的学习，与之前完全不同，变得更自由了，变得更深、更广了。编程的学习，也与其他的学习有所不同，近半年来，我切身地感受到编程的学习不仅要把理论搞懂，更重要的是动手实践，敲代码，解决问题，实践操作，这样学起来更加得舒服，也更扎实。大一上，学习到的知识与内容非常地多，而且非常地杂。但是，重点还是编程能力，数学思维，以及英语素养。高考完的暑假，我自学了C语言的一部分内容，这也让我能在专业课上学的比较舒服。在上了一些专业课与理论课后，我切身地感受到自学的重要性。因此，我开始真正学习到对自己有用的知识。学习，挺枯燥乏味的，但也可以是充满趣味的，通过学习C语言，我可以写出一两个小游戏，利用各种函数还能实现一些创意功能，如用蜂鸣函数，调整频率实现一首歌曲。<br><img src="https://s2.loli.net/2023/07/25/oiQy2I8fcYpTlXA.jpg" alt="教室学习"><br>近朱者赤，近墨者黑。很荣幸，通过iflab的面试，加入了这个大家庭。在社团中，导师们分享学习的经验与技巧，介绍各类比赛与经验，交流行业知识与现状，热心回答我们的疑问。因此，我也学到了很多，我创建了自己Github，有了自己的代码仓库，我也成功搭建部署了自己的个人博客，并且对行业的情况有了自己的认识与了解，通过FCC的学习打卡，对网页，前端内容有了一定的了解……相互学习是能促进进步的，别人有优点，去向他请教学习，何尝不是对自己的一种好处呢？勾心斗角，只会阻碍自己的进步。本学期，虽然离自己的学习目标还差挺大距离，但也收获许多，只能说，继续加油吧。<img src="https://s2.loli.net/2023/07/25/7BuPqwI1Zj69k2Y.jpg" alt="FCC打卡奖品"></p>
<h2 id="2-3、生活态度"><a href="#2-3、生活态度" class="headerlink" title="2.3、生活态度"></a>2.3、生活态度</h2><p>2022年，发生了许多变化，个人在变，社会在变，整个世界都在变。谁能想到，上半年还在高三的教室刷题的我，现在已经开始敲代码了呢？谁能想到，11月还在封控的疫情，12月年末就放开了呢？生活吧，总是会和你开玩笑，你得笑着回应它。不得不说，这一年里，我的人生观，价值观都在悄悄地发生着改变，除了学习呢，我也学会了很东西。这一年的疫情，压得人喘不过气来，有人抱怨，有人吐槽，社会就是如此，有些东西你无法改变，遵从自己的内心，同时做好自己，这不失为一种明智的选择。人，茫茫碌碌，到处奔波，但不应只有工作和学习。校园的健康跑，包括我在内挺多人吐槽的，但是3公里跑步的那些天，让我感觉非常舒服，睡眠质量提高了，学习效率也提升了，整个人的状态也是完全不同的。闲暇之余，我也会拿起吉他，随性弹唱一曲，哼唱两句：“长亭外，古道边，芳草碧连天……”。追逐浮世骄阳，也别错过人间万象。<img src="https://s2.loli.net/2023/07/25/RbGvO54aQ3UTuxD.jpg" alt="日落"></p>
<h1 id="3、展望2023"><a href="#3、展望2023" class="headerlink" title="3、展望2023"></a>3、展望2023</h1><p>2022年，有收获，也有遗憾，那就展望一下2023年<br><br>1.2023年开始持续输出博客，坚持输出达到20篇。<br><br>2.寒假学习数据结构与算法和C++，筑牢基础。<br><br>3.2023年一整年完成计算机四大件的学习，并尝试做一些中大型项目。<br><br>4.拿下四六级，驾驶证，取得3个以上计算机相关的比赛奖项。<br><br>5.阅读更多的书籍，专业书籍，如《C和指针》、《C陷阱与缺陷》、《大话数据结构》等与其他方面书籍。<br><br>6.游历北京城，参加户外实践，参观景点，各种展览，增长见识。<br><br>7.坚持体育锻炼，跑步、骑行、参加一些球类运动。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>悟已往之不谏，知来者之可追。新的一年要来了，过去的就让它过去吧，寒冬过后，都会回暖，2023，我们一起加油呀！新年快乐！</p>
<p><img src="https://s2.loli.net/2023/07/25/mVQKNhn1Zo4pkbY.webp" alt="烟花"></p>
]]></content>
  </entry>
  <entry>
    <title>2023年最后一个月了，当初的愿望实现了吗？</title>
    <url>/2023/11/30/2023%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%9C%88%E4%BA%86%EF%BC%8C%E5%BD%93%E5%88%9D%E7%9A%84%E6%84%BF%E6%9C%9B%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/11/30/R2VHYyZDFcTs4rG.png" alt="当初的愿望实现了吗？">  </p>
<p>不知不觉，2023年只剩下最后一个月了，只能说，时光过得好快！今年是梦幻的一年，好像做了很多事，但也好像没做什么，也许是接触到的东西比之前多了吧，我也体验了很多东西，同时我也切身感受到我的思维、价值观、人生观也一直在潜移默化地改变着。这么说似乎也没错，因为人本来就是一直会变的嘛。今天重新翻看了之前自己写的一些文章，突然看到了年初立下的小目标： </p>
<span id="more"></span>

<hr>
<p><img src="https://s2.loli.net/2023/11/30/OFlHeGy9LTv5CBE.png" alt="朝花夕拾"></p>
<p>也不能说是目标吧，其实也就是自己当时的一些展望，与当时的想法状态关系较大。当时真是想法多啊，别人列个三四条，自己列了六七条，看来当时的我还是有点自信乐观在的，好笑的是第一条目前就没有实现。其实上半年也有写，但是没有把他们写在自己的博客上吧，还剩一个月，想达到20篇估计也不可能了，而且我个人不喜欢强行为了写文章而写文章，我觉得写文章的目的是把自己的想法表现出来，不喜欢“为赋新词强说愁”。虽然这些目标没有完全实现吧，有遗憾和可惜，但也好像大部分也都实现了：</p>
<ul>
<li>今年有持续输出博客，表达自己的想法，记录自己的生活。</li>
<li>寒假的时候也提前学完了常见数据结构和算法，同时也把C++学了一遍，在上半年经过选拔加入了ACM校队，参加了一些网络算法赛，也体会到了AC题目时的快乐。项目是做了几个，但估计都算不上中大型项目，现在想想还是得多积累经验才行，把基础打好也更重要些。</li>
<li>计算机四大件，其实都有了解接触，系统学了三大件，近期期末，可支配的时间也不多，多利用时间学吧。</li>
<li>上半年拿下了四级，暑假一举拿下了驾驶证，12月份考6级，希望能过吧！奖项也有获得些吧，互联网+市赛证书、程序设计竞赛证书、创新杯一等奖等。</li>
<li>读过的书籍：《C++ Prime Plus》、《C++ Prime》、《数据结构与算法C++版》、《鸟哥的Linux私房菜》、《计算机网络–谢希仁版》、《Everyone is PM》、《小王子》、《亲密关系》、《浪潮之巅》等。</li>
<li>去过的景点：故宫、颐和园、什刹海、鼓楼、南锣鼓巷、王府井、清华、北大、北邮、北师大、蟒山等，这些是北京城的；其他城市：上海外滩、杭州西湖、天津之眼、天津东堤公园等。展览实践：北大无人机挑战赛开幕式、国际大学生魔术表演、WWDC之夜北京会场、字节跳动OpenDay等。</li>
<li>有在坚持运动、校园6公里马拉松、乒乓球、每学期42天的三公里跑等</li>
</ul>
<p>有点不可思议，好像还是实现得挺多的，虽然这些目标不是什么很伟大的吧，但是当你回头再看的时候，好像自己真的完成了这样的一个个小目标，原来自己真的也挺棒的！说实话，今年做过的、体验过东西的远比这些所列目标多得多，而这些目标其实也只是自己的一点展望，我认为人不应该被这些所谓立下的flag而倍感压力导致困顿，而是以此为动力鞭笞自己向前，这应该是一种激励作用，而不是什么负担。现在回过头来看，其实自己也没有能完全实现这些‘目标’嘛，但是又何妨呢？要是都能完全实现的话，那我就马上立个超大超梦幻的flag！</p>
<hr>
<p>哈哈，用心去做自己喜欢的，热爱的，并坚持下去就好啦，这不还剩一个月嘛，“莫道桑榆晚，为霞尚满天。”，好好珍惜喽！</p>
]]></content>
  </entry>
  <entry>
    <title>CMake用一用就会了？！</title>
    <url>/2024/09/08/CMake%E7%94%A8%E4%B8%80%E7%94%A8%E5%B0%B1%E4%BC%9A%E4%BA%86%EF%BC%81%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/09/28/u9PqLiXtlcRKwOy.png"></p>
<pre><code>“一个厨子做菜，抛开味道不谈，他至少得知道原材料是什么以及原材料在哪。”
</code></pre>
<span id="more"></span> 
<p>前些日子接触了一些规模相对较大的项目，但一开始的项目编译就给我来了个下马威，该项目使用CMake构建，之前我对于CMake还停留在其只是一个项目构建工具的阶段，对里面的操作，细节不少还是比较生疏与模糊，所以对于我来说要把项目跑起来还不简单，于是乎就去学习并实践了CMake这个东西，最终也解决了相关问题， 这过程让我对于一些编译链接的底层有了更深入的理解，我也对如何组织我的代码，如何组织构建一个工程项目有了新的认识</p>
<hr>
<h1 id="CMake简单实战"><a href="#CMake简单实战" class="headerlink" title="CMake简单实战"></a>CMake简单实战</h1><p>我们完成一个计算小demo，以此来感受一下CMake的使用，在这里就直接用Visual Studio来完成<br>首先打开心爱的VS，然后我们选CMake工程，创建一个CMake工程项目。先清空一下自动生成的文件，然后添加一些目录与文件，工程结构如图所示：<br><img src="https://s2.loli.net/2024/09/28/wYxC9y5lHJNR7Q6.png"><br>其实要写的和平时的项目没啥区别，我们先把该demo写完：</p>
<ul>
<li>main.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mul.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;divi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">114</span>, <span class="number">514</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sub</span>(<span class="number">514</span>, <span class="number">114</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">mul</span>(<span class="number">514</span>, <span class="number">114</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">divi</span>(<span class="number">514</span>, <span class="number">114</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>add.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>add.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sub.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>sub.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>剩下的代码类似，这样我们就构建好了一个Cal的demo,但是我们现在运行不起来的，因为我们这个是CMake工程，得编写一下CMake文件，打开我们的CMakeLists.txt文件,写下基础几步</p>
<ul>
<li><strong>首先指定CMake最低版本</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">3.8</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>定义项目名称</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">project</span> (<span class="string">&quot;CMakeProject1&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><strong>添加源文件</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(cal</span><br><span class="line">    src/main.cpp</span><br><span class="line">    cal/add.cpp</span><br><span class="line">    cal/sub.cpp</span><br><span class="line">    cal/mul.cpp</span><br><span class="line">    cal/divi.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
这里是为项目添加一个可执行目标文件cal，然后后面的main.cpp、add.cpp等都是该目标文件所要用到的源文件。</li>
<li><strong>添加头文件路径</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>(cal)</span><br></pre></td></tr></table></figure>
我们这里的头文件都包含在cal这个目录下，指定后就会告诉编译器去这个路径下去找所要包含的头文件</li>
</ul>
<p><strong>demo完整CMakeLists代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (<span class="string">&quot;CMakeProject1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span>(cal)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(cal</span><br><span class="line">    src/main.cpp</span><br><span class="line">    cal/add.cpp</span><br><span class="line">    cal/sub.cpp</span><br><span class="line">    cal/mul.cpp</span><br><span class="line">    cal/divi.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>编写完CMake文件后，我们按下<strong>ctrl + s</strong>保存一下，则会自动完成CMake生成  </p>
<p><img src="https://s2.loli.net/2024/09/28/8jspEXcF4WTbJum.png"><br>接着我们会看到多了一个cal的可执行程序：<br><img src="https://s2.loli.net/2024/09/28/t79SarKzh2AoYFs.png"></p>
<p>运行该程序，即可看到输出结果：  </p>
<p><img src="https://s2.loli.net/2024/09/28/KgOId42bwUVNJa1.png"> </p>
<p>至此我们就完成了这个用CMake来构建的cal的demo<br>当然我们也只是完成了构建并成功跑了起来，而对于为什么要这样做，这样做的目的是什么，还没有去探究，比如为什么需要指定一个可执行程序？为什么需要指定头文件的包含目录？等等，我们接下来就去看看这些做法的意义。</p>
<hr>
<h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><pre><code>“一个厨子做菜，抛开味道不谈，他至少得知道原材料是什么以及原材料在哪。”
</code></pre>
<h2 id="从源文件到可执行文件过程中发生了什么？"><a href="#从源文件到可执行文件过程中发生了什么？" class="headerlink" title="从源文件到可执行文件过程中发生了什么？"></a>从源文件到可执行文件过程中发生了什么？</h2><p>我们都知道，当我们写好一个文件后，想要把它变成可执行文件，要经历以下几步：</p>
<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ul>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>编译器在正式编译之前会对源代码进行预处理。这一步主要包括：</p>
<ul>
<li>处理头文件的包含（例如C&#x2F;C++中的#include）。</li>
<li>处理宏定义和替换（例如#define和#ifdef等）。</li>
<li>移除注释和执行条件编译指令。</li>
</ul>
<p>预处理的结果是一个中间代码文件，该文件扩展名通常还是源文件的扩展名（如.i或.ii，根据语言和编译器不同有所区别）。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译阶段，编译器将预处理过的源代码转换为中间代码或目标代码（即机器指令的汇编语言）。该过程包括：</p>
<ul>
<li>词法分析：将代码分解为基本语法元素（token）。</li>
<li>语法分析：检查代码的结构是否符合编程语言的语法规则，生成抽象语法树（AST）。</li>
<li>语义分析：检查代码的逻辑是否合理，例如类型检查、变量是否声明等。</li>
<li>中间代码生成：生成机器无关的中间表示形式。</li>
<li>目标代码生成：将中间表示转为机器码，通常是汇编代码。此时生成的文件叫目标文件（.o或.obj）。</li>
</ul>
<p>目标文件是计算机可理解的低级代码，但尚不可执行。<strong>这里具体的可以看《编译原理》这门课与教材。</strong></p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><ul>
<li>编译器生成的汇编代码通过汇编器（assembler）转化为机器语言的二进制形式，成为目标文件（Object File）。在这个阶段，代码还不能独立运行。</li>
<li>目标文件中可能包含了未解析的符号（例如函数调用或变量引用），这些符号将在链接阶段被解析。</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li>链接器（Linker）负责将所有目标文件、库文件以及依赖项链接在一起，生成一个完整的可执行文件。</li>
<li>链接分为两种：<br>（1）静态链接：将所有的库函数和依赖项直接嵌入到可执行文件中。生成的可执行文件体积较大，但不依赖外部库。<br>（2）动态链接：链接器将代码和动态库的引用放在可执行文件中，在运行时加载这些库。生成的可执行文件较小，依赖运行时的库文件（例如.dll或.so）。</li>
<li>链接器还会解析目标文件中的符号，将函数调用和变量引用的地址填充到正确的位置。</li>
</ul>
<p>对于链接来说，链接器会做很多事情，如<strong>符号解析、地址分配、重定位、节段合并、库文件处理等，具体可以看看《计算机的底层秘密》、《程序员的自我修养》。</strong><br>经过这几步，一个可执行程序就诞生了，我们可以直接在操作系统中运行起来。那其实我们再回到CMake上，也同样在做这几步，<strong>目标文件，依赖项，库。</strong></p>
<hr>
<h3 id="错误探究"><a href="#错误探究" class="headerlink" title="错误探究"></a>错误探究</h3><p>接下来我们尝试对刚才的demo中的CMakeLists做一些变动，看看会发生什么</p>
<ul>
<li><strong>注释掉include_directories</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">include_directories</span>(cal)</span><br></pre></td></tr></table></figure>
ctrl + s保存后，重新生成，不出意外我们会喜提一个错误：<blockquote>
<p>严重性	代码	说明	项目	文件	行	禁止显示状态<br>错误	C1083	无法打开包括文件: “add.h”: No such file or directory	D:\C++程序设计\CMakeProject1\out\build\x86-debug\CMakeProject1	D:\C++程序设计\CMakeProject1\src\main.cpp	2</p>
</blockquote>
</li>
</ul>
<p>	</p>
<p>C1083 无法打开包括文件”add.h”，这个错误表明，**我们引入了一个”add.h”的文件，但是编译器无法找到，编译器查找””引入的文件时，首先会在当前源文件所在目录去找，而我们的main.cpp与add.h文件并不在同一个目录下，所以会找不到，接着编译器会再去我们所指定的目录去找，也就是前面的include_directories，由于我们已经将其注释，所以编译器也无法找到，于是就会发生，无法打开”add.h”的错误。<br>我们把注释取消，告诉编译器去”cal”目录下查找，ctrl + s保存后重新生成，全部生成成功。</p>
<ul>
<li><strong>注释掉其中一个依赖的cpp文件</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(cal</span><br><span class="line">    src/main.cpp</span><br><span class="line">    <span class="meta">#cal/add.cpp</span></span><br><span class="line">    cal/sub.cpp</span><br><span class="line">    cal/mul.cpp</span><br><span class="line">    cal/divi.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
ctrl + s保存后，重新生成，不出意外的喜提一个链接错误：<blockquote>
<p>严重性	代码	说明	项目	文件	行	禁止显示状态<br>错误	LNK2019	无法解析的外部符号 “int __cdecl add(int,int)” (?add@@YAHHH@Z)，函数 _main 中引用了该符号	D:\C++程序设计\CMakeProject1\out\build\x86-debug\CMakeProject1	D:\C++程序设计\CMakeProject1\out\build\x86-debug\main.cpp.obj	1</p>
</blockquote>
</li>
</ul>
<p>Link2019 无法解析的外部符号，相信很多朋友都遇到过这个错误，报这个错误的原因其实就是在链接阶段，通这意味着编译成功了，但在链接阶段未能找到某个外部符号（函数或变量）的定义。具体错误信息表明：在 main.cpp 文件中的 main 函数里调用了一个函数 add，但链接器无法找到这个 add 函数的定义，因此抛出了“无法解析的外部符号”的错误。	<strong>那为什么编译能过呢？因为我们已经给它声明了，在main.cpp中引用了add.h的头文件，告诉编译器有这个函数，编译器不需要知道这个函数的实现的具体位置，而那是在链接阶段做的事情。</strong><br>我们把注释取消，添加目标文件所依赖的add.cpp，这时候在链接阶段就能去找到了，ctrl + s保存后重新生成，生成成功。</p>
<blockquote>
<p><strong>“一个厨子做菜，抛开味道不谈，他至少得知道原材料是什么以及原材料在哪。”</strong>，而我们要生成的可执行文件就是这道菜，原材料就是我们所需要的依赖文件以及库文件，原材在哪就是我们需要去指定找的路径与过程，而CMake的那些语法正是在做这些事情。</p>
</blockquote>
<hr>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>前面我们通过回顾小学时期学的编译链接过程与对demo的分析，已经初步了解了CMake的这些语法在干嘛，以及为什么要这样做，在不依赖任何第三方库的情况下，我们已经能够脱离任何IDE来跑起来一个可执行程序了，现在我们就来探究一下库这个东西以及如何在CMake上完成对库的操作。<br>首先回顾一下库的知识:</p>
<ul>
<li>库：是一个代码的集合，可以被多个程序共享。库提供了特定功能的实现，开发者可以直接调用库中的代码，而不需要重新实现这些功能。库通常分为两个类型：静态库和动态库。</li>
</ul>
<h3 id="静态库与静态链接"><a href="#静态库与静态链接" class="headerlink" title="静态库与静态链接"></a>静态库与静态链接</h3><p><strong>静态库回顾</strong></p>
<ul>
<li><p>定义：静态库（Static Library）是指在编译时将库中的代码直接嵌入到可执行文件中。这意味着当你编译程序时，静态库的代码会被复制到最终的可执行文件中。</p>
</li>
<li><p>文件扩展名：在Windows下通常是 .lib，在Unix&#x2F;Linux下通常是 .a。</p>
</li>
<li><p>优点：<br>（1）独立性：静态库的代码被包含在可执行文件中，因此运行时不需要依赖库文件，减少了部署时的复杂性。<br>（2）速度：在程序启动时，无需加载外部库，可能会稍微提高启动速度。</p>
</li>
<li><p>缺点：<br>（1）体积：因为每个可执行文件都包含库的代码，生成的可执行文件通常会比较大。<br>（2）更新困难：如果库的实现需要更新，所有使用该库的可执行文件都必须重新编译。</p>
</li>
</ul>
<h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><p>我们来完成一个静态库的制作，也是一个计算的demo，只不过我们把所需的源文件都制作成库。项目开始的结构：<br><img src="https://s2.loli.net/2024/09/28/U4WTHqj5EwGcb8z.png"><br>首先是head.h头文件：</p>
<ul>
<li>head.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
我们打包成库时也要给比人提供头文件，这样才方便调用，这里就直接把头文件放入一个head.h中</li>
</ul>
<p>然后是各功能的源文件：</p>
<ul>
<li>add.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sub.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其余的类似<br>接着编写CMakeList文件：</li>
<li>CMakeList文件<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line"><span class="built_in">project</span>(CMakeProject1)</span><br><span class="line"></span><br><span class="line"># 设置包含头文件目录</span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CMAKE_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 源文件列表</span><br><span class="line"><span class="built_in">set</span>(SOURCES</span><br><span class="line">    src/add.cpp</span><br><span class="line">    src/sub.cpp</span><br><span class="line">    src/mul.cpp</span><br><span class="line">    src/divi.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建静态库</span><br><span class="line"><span class="built_in">add_library</span>(cal STATIC $&#123;SOURCES&#125;)</span><br><span class="line"></span><br><span class="line"># 设置库文件输出目录</span><br><span class="line"><span class="built_in">set_target_properties</span>(cal PROPERTIES</span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
这里的set 指将所需源文件都命名为一个变量<strong>SOURCES</strong>，以方便后面使用，然后创建静态库使用<strong>add_library</strong>，指定类型为<strong>STATIC</strong>表明是静态库，然后后面跟 **${SOURCES}**，这里的$指的是取这个变量的值，取出来也就是：<blockquote>
<p>  src&#x2F;add.cpp<br>  src&#x2F;sub.cpp<br>  src&#x2F;mul.cpp<br>  src&#x2F;divi.cpp</p>
</blockquote>
</li>
</ul>
<p><strong>set_target_properties</strong>这里设置库的输出路径，也就是&#x2F;lib文件夹下。<br>编写完后，ctrl+s后重新生成，可以发现lib文件夹下多了一个cal.lib文件<br><img src="https://s2.loli.net/2024/09/28/54OWsSvF8EMhitp.png" alt=".jpg"><br>这样我们就完成了静态库的制作</p>
<h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><p>接下来我们尝试链接刚才生成的库文件：<br>项目结构如下：<br><img src="https://s2.loli.net/2024/09/28/I72o5ACOUi3p48F.png"><br>编写相关代码：</p>
<ul>
<li>main<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sub: &quot;</span> &lt;&lt; <span class="built_in">sub</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Mul: &quot;</span> &lt;&lt; <span class="built_in">mul</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Div: &quot;</span> &lt;&lt; <span class="built_in">divi</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>CMakeList<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line"><span class="built_in">project</span>(CMakeProject1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(test src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_include_directories</span>(test PRIVATE include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_directories</span>(test PRIVATE lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span>(test cal)</span><br></pre></td></tr></table></figure>
Ctrl+s保存后重新生成，运行查看结果：<br><img src="https://s2.loli.net/2024/09/28/5FuK8D3UPnVZcbL.png"><br>成功使用静态库，这样我们就学会了如何用CMake制作静态库并使用静态库</li>
</ul>
<h3 id="动态库与动态链接"><a href="#动态库与动态链接" class="headerlink" title="动态库与动态链接"></a>动态库与动态链接</h3><p><strong>动态库知识点回顾：</strong></p>
<ul>
<li>定义：动态库（Dynamic Library）是在运行时加载的库，编译时程序只链接库的接口。动态库的代码不被直接包含在可执行文件中，而是在程序运行时通过操作系统动态加载。</li>
<li>文件扩展名：在Windows下通常是 .dll，在Unix&#x2F;Linux下通常是 .so。</li>
<li>优点：<br>（1）共享：多个程序可以共享同一个动态库的实例，从而节省内存和磁盘空间。<br>（2）更新便利：更新动态库时，只需替换库文件，不需要重新编译依赖该库的所有程序。<br>（3）小型可执行文件：可执行文件体积小，因为它不包含库的实现。</li>
<li>缺点：<br>（1）运行时依赖：在运行时必须确保相关的动态库存在，否则会导致程序无法启动。<br>（2）加载时间：动态库在运行时加载可能会稍微增加启动时间。<br>（3）版本控制：不同版本的动态库可能引发“地狱版本问题”，即某个程序可能需要特定版本的库，导致冲突。</li>
</ul>
<h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><p>制作动态库的过程大体和静态库一样，不过需要多注意几个步骤，下面我们同样完整的制作一个动态库。项目开始的结构：<br><img src="https://s2.loli.net/2024/09/28/U4WTHqj5EwGcb8z.png" alt="-.jpg"></p>
<p>首先是head.h头文件：</p>
<ul>
<li>head.h<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MYLIBRARY_EXPORTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIBRARY_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIBRARY_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">double</span> <span class="title">divi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
这里我们使用宏定义来区分导入导出，也就是如果定义了了导出宏，那么就使用“__declspec(dllexport)”，如果没有定义，则为“__declspec(dllimport)”</li>
</ul>
<p>然后是各功能的源文件：</p>
<ul>
<li>add.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可以看到add函数前面多了个“MYLIBRARY_API”，这个东西我们在head.h对其进行了定义<br>导出库时，即<strong>代表“__declspec(dllexport)”，这将告诉编译器我们要将其导出一个为库文件，如果没有这个东西，那么后面生成的库文件可能会少了.lib文件，导致生成时无法找到。 这是由于导出为动态库时，不仅包含.dll文件，还要生成一个.lib，告诉编译器动态库的信息，.lib文件在编译时就已经确定，而.dll在运行时才会去链接。</strong> 当然“__declspec(dllexport)”这个关键字只有在windows下使用MSVC的编译器才会要这样做，在其他平台上就不需要或者情况不是这样。<br>其他的源文件也类似：</li>
<li>sub.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function">MYLIBRARY_API <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
剩下的以此类推</li>
</ul>
<p>然后还需编写CMakeList文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line"><span class="built_in">project</span>(CMakeProject1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">include_directories</span>($&#123;CMAKE_SOURCE_DIR&#125;/include)</span><br><span class="line"></span><br><span class="line"># 源文件列表</span><br><span class="line"><span class="built_in">set</span>(SOURCES</span><br><span class="line">    src/add.cpp</span><br><span class="line">    src/sub.cpp</span><br><span class="line">    src/mul.cpp</span><br><span class="line">    src/divi.cpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 创建动态库，定义 MYLIBRARY_EXPORTS 宏以导出符号</span><br><span class="line"><span class="built_in">add_library</span>(cal SHARED $&#123;SOURCES&#125;)</span><br><span class="line"><span class="built_in">target_compile_definitions</span>(cal PRIVATE MYLIBRARY_EXPORTS)</span><br><span class="line"></span><br><span class="line"># 设置库文件输出目录</span><br><span class="line"><span class="built_in">set_target_properties</span>(cal PROPERTIES</span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib</span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib</span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_SOURCE_DIR&#125;/lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里的set 指将所需源文件都命名为一个变量<strong>SOURCES</strong>，以方便后面使用，然后创建动态库也使用<strong>add_library</strong>，只不过我们要指定为<strong>SHARED</strong>，而<strong>target_compile_definitions</strong>则代表在编译时的宏定义，即定义为导出，那么上面的<strong>MYLIBRARY_API</strong> 就代表  <strong>__declspec(dllexport)<strong>。</strong>set_target_properties</strong>这个语句则代表库文件的输出目录，可以指定所生成库文件相关的东西的输出目录，这三个分别代表：</p>
<ul>
<li>ARCHIVE_OUTPUT_DIRECTORY：指定静态库（.lib 或 .a 文件）的输出目录。</li>
<li>LIBRARY_OUTPUT_DIRECTORY：指定动态库（.dll 或 .so 文件）的输出目录。</li>
<li>RUNTIME_OUTPUT_DIRECTORY：指定可执行文件和动态库的运行时文件的输出目录。</li>
</ul>
<p>经过上面几步，我们就编写好了，接下来ctrl+s保存后，生成全部，可以看到在指定的输出目录lib下多了一些东西：<br><img src="https://s2.loli.net/2024/09/28/aY8MlUA7IhDiTxz.png"><br>至此我们就完成了动态库的制作。</p>
<h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>我们就拿刚才制作的库文件，来链接一下，重新建一个项目或者把项目结构设置成这样：<br><img src="https://s2.loli.net/2024/09/28/I72o5ACOUi3p48F.png"><br>head.h文件就不用改了，而保留cal.lib文件是因为编译时需要告诉编译器动态库的信息<br>给出相关代码（和静态库的一样其实）：</p>
<ul>
<li>main.cpp<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Add: &quot;</span> &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sub: &quot;</span> &lt;&lt; <span class="built_in">sub</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Mul: &quot;</span> &lt;&lt; <span class="built_in">mul</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Div: &quot;</span> &lt;&lt; <span class="built_in">divi</span>(a, b) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>编写CMakeList:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"># 项目名称</span><br><span class="line"><span class="built_in">project</span>(CMakeProject1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(test src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_include_directories</span>(test PRIVATE include)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_directories</span>(test PRIVATE lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">target_link_libraries</span>(test cal)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>target_link_directories</strong>表示目标文件所要链接的库文件，<strong>target_link_libraries</strong>则是指定去哪个路径下去找。写完后我们ctrl+s保存，全部生成，生成成功。然而，如果此时直接点击运行的话，不出意外我们又会喜提一个报错：<br><img src="https://s2.loli.net/2024/09/28/tdSCfIJYy8Hms2R.png"><br>相信很多朋友在做项目时都碰到类似的问题，找不到.dll，只是因为我们的.dll文件在可执行程序调用时，找不到它在哪，其实我们只需要让它找得到就好了，最好的方法就是直接将.dll文件放和可执行文件放在同一个路径下，或者指定.dll的路径，这里我直接把他们放在同一个目录下:<br><img src="https://s2.loli.net/2024/09/28/dnBqhpOSgyoLxYv.png"><br>这时候，我们重新运行一下，发现大功告成：<br><img src="https://s2.loli.net/2024/09/28/LOxSAeQkpJzsIWv.png"></p>
<p>至此，我们就学会了如何制作和使用动态库了，现在我们已经可以完成所有项目（包括使用第三方库）的项目的构建了，可以随心所欲了属于是。当然，我们现在学的内容，也只是一些基本的操作与使用，其实还有很多东西，比如<strong>find_package</strong>等一些更高级的内容，这些后续有机会探讨。</p>
<hr>
<h1 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h1><p>上面我们完成了一个用CMake构建项目的简单实战，但是一开始用的话，肯定会有和我一样的疑问：<strong>CMake这么麻烦，我为什么要用CMake呢？我直接打开VS，新建一个空项目，然后添加源文件，添加头文件，再一键运行不就好了吗？</strong> 的确，打开VS直接添加文件一件运行似乎方便很多，不过在一些情况中，CMake有其强大之处：</p>
<ul>
<li><strong>跨平台支持</strong><br>假设我们开发了一款软件，该软件既要能在windows上运行，又要能在Linux上运行，或者在其他更多的操作系统上运行，我们在小学三年级中学过，不同的操作系统对于项目的构建是不一样的，他们有各自的一套规则，那对于同一个项目，我们想要进行编译链接生成可执行程序，就需要有不同的操作，那想要成功运行起来，我们就要针对不同的操作系统编写不同的文件，而则个工程量可是不小的，而<strong>CMake 是一个跨平台的工具，支持多种操作系统和编译器（如 Linux、macOS、Windows，支持 Makefiles、Visual Studio 项目、Xcode 项目等）。使用 CMake，开发者可以通过一套统一的构建脚本（CMakeLists.txt）来生成不同平台上的构建文件，从而避免了为每个平台编写不同的构建配置。</strong></li>
<li><strong>更好的拓展与管理</strong><br>CMake 提供了广泛的模块支持，允许开发者根据项目的需求来添加、配置和扩展项目。通过find_package()可以轻松查找第三方库，如 Boost、OpenSSL、Qt 等。CMake 支持模块化的开发，可以管理大型项目中的多个子项目或模块。</li>
<li><strong>简化复杂的构建过程</strong><br>对于多语言、多库、多目标的项目，手动编写平台相关的构建文件（如Makefile或Visual Studio解决方案）可能会变得极为复杂。CMake 提供了自动化和标准化的构建过程，可以处理复杂的依赖关系、库的链接以及编译选项的设置。</li>
<li>……</li>
</ul>
<p>CMake 之所以成为主流的构建工具，是因为它解决了跨平台编译、依赖管理、复杂项目构建等方面的痛点，简化了开发者的构建流程，并且提供了良好的可扩展性和灵活性。尤其对于需要支持多个操作系统和编译器的项目，CMake 会是个好的选择。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习并使用CMake的过程中，我们还学习了很多本质的东西，与其说在学CMake，倒不如说是在学如何去构建一个项目，学习编译链接原理，CMake看似复杂的背后其实蕴含了很多“基础”的东西，知其然好，知其所以然更好，只有知道自己在做什么，以及去做的途径与方法，才能把事情做好，正如开头所言：</p>
<pre><code>“一个厨子做菜，抛开味道不谈，他至少得知道原材料是什么以及原材料在哪。”
</code></pre>
<p>好好享受做菜的过程吧！</p>
]]></content>
  </entry>
  <entry>
    <title>QT报错：ERROR: Unknown module(s) in QT: core5compat</title>
    <url>/2024/01/31/QT%E6%8A%A5%E9%94%99%EF%BC%9AERROR-Unknown-module-s-in-QT-core5compat/</url>
    <content><![CDATA[<h1 id="Qt报错：error-Project-ERROR-Unknown-module-s-in-QT-core5compat"><a href="#Qt报错：error-Project-ERROR-Unknown-module-s-in-QT-core5compat" class="headerlink" title="Qt报错：error: Project ERROR: Unknown module(s) in QT: core5compat"></a>Qt报错：error: Project ERROR: Unknown module(s) in QT: core5compat</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天在github上下载了一些项目源码进行学习，但是当我用自己的QT Creator进行构建编译时，出现了报错：<br><img src="https://s2.loli.net/2024/01/31/gtyOW2aksq9dZzp.png" alt="显示灰色.png"><br><img src="https://s2.loli.net/2024/01/31/BURAG4cM17JVlsu.png" alt="报错信息.png">  </p>
<span id="more"></span>  
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>根据报错信息，显示不知道的模块：core5compat，应该是自己的QT中缺少了环境名为：core5compat的模块。<br>经过查询后得知，自己的Qt版本是Qt 6，是Qt框架的最新主要版本，相比于Qt 5，它提供了许多改进和新特性，但也移除了一些旧特性和类。core5compat 模块：为了帮助开发者从Qt 5迁移到Qt 6，Qt 6提供了一个名为 core5compat 的兼容性模块。这个模块包含了一些在Qt 6中被弃用但在Qt 5中常用的类和方法。错误消息 “Unknown module(s) in QT: core5compat” 指的是在尝试编译或运行一个使用Qt框架的项目时，Qt环境中缺少名为 core5compat 的模块。这通常出现在尝试将基于Qt 5的代码迁移到Qt 6时，因为Qt 6中移除或更改了一些在Qt 5中存在的功能。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>首先检查自己项目构建时用的QT版本，一般在打开.pro文件时即可选择，<strong>如下图，我这里是用的Qt6.2.4，项目版本得看这个，不要看help中的about，那个不一定是本项目所用的</strong><br><img src="https://s2.loli.net/2024/01/31/xryFA9zZMjwTJ2R.png" alt="项目构建版本.png"></li>
<li>接着打开并运行<strong>Qt Maintenance Tool。通常可以在安装Qt的文件夹中找到它</strong>，在Qt Maintenance Tool中，执行以下操作：</li>
</ul>
<ol>
<li>选择“添加或删除组件”（Add or Remove Components）。</li>
<li>展开已安装的Qt版本，例如我这的 Qt 6.2.4。</li>
<li>寻找名为“Qt 5 Compatibility Module”或类似名称的组件，它就是 core5compat 模块。</li>
<li>选中该组件，然后点击“下一步”（Next）来开始安装。</li>
<li>等待安装完成后，关闭Qt Maintenance Tool。<br><img src="https://s2.loli.net/2024/01/31/EFicJb4kaUw7DpL.png" alt="Qt Maintenance Tool.png"></li>
</ol>
<ul>
<li><p>然后更新项目文件，打开项目文件（通常是一个以 .pro 结尾的文件），并确保包含了core5compat模块。<strong>如果文件中没有“QT +&#x3D; core5compat”这行代码的话，还需要在.pro文件中添加：<br>QT +&#x3D; core5compat，这会告诉Qt构建系统您的项目依赖于core5compat模块。</strong></p>
</li>
<li><p>最后重新打开并编译项目，可以clean然后rebuild，即可正常运行<br><img src="https://s2.loli.net/2024/01/31/CwOEmnJkSBILR6y.png" alt="成功运行.png"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>STL--vector容器(构造、遍历、插入删除、容量大小、数据存取、动态扩容等)</title>
    <url>/2023/11/11/STL-vector%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天在写代码的时候用到STL较多，也感受到了STL的强大，于是我重新温习了一遍STL的内容，并把一些基础的东西，重要的内容总结提炼出来，这篇是vector篇。C++的STL给我们提供了很多可用的容器，vector就是最常用的容器之一,vector应该掌握的基础内容包括构造函数、元素的插入插入删除、赋值、存取等操作。重点内容应该掌握vector的扩容机制、内存大小的变化原理等。</p>
<span id="more"></span>  
<h2 id="1、vector简介"><a href="#1、vector简介" class="headerlink" title="1、vector简介"></a>1、vector简介</h2><ul>
<li>vector容器为可变长数组（动态数组），可以随时插入删除元素。</li>
<li>vector被称为向量容器，因为该容器擅长在尾部插入或删除元素， 在O（1）时间就能够完成;而如果要在容器头部或者中间插入数组元素，则需花费O（N）的时间，因为他需要将后面的元素往后移。（其实原理也就类似于我们在数据结构与算法中学的顺序表）</li>
<li>vector与普通数组大的区别在于：数组是静态数组（容量固定的数组），而vector可以动态拓展。即可以进行容器的插入和删除，这个过程中，vector会动态调整所占用的空间。</li>
<li>vector访问元素也同样要遵守不能越界的规则，否则会造成内存的安全隐患。</li>
</ul>
<h2 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h2><p>(1)功能：用来创建vector容器<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> vector&lt;T&gt; v;<span class="comment">//默认无参构造</span></span><br><span class="line"><span class="number">2.</span> vector&lt;T&gt; v&#123;elem1, elem2, elem3 ...&#125;<span class="comment">//指定元素构造</span></span><br><span class="line"><span class="number">3.</span> <span class="function">vector&lt;T&gt; <span class="title">v</span><span class="params">(n, elem)</span><span class="comment">//将n个elem拷贝为元素构造</span></span></span><br><span class="line"><span class="function">4. vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span><span class="comment">//拷贝另一个vector构造</span></span></span><br><span class="line"><span class="function">5. vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span><span class="comment">//区间构造，将v1区间的begin()到end()的元素赋值给v2；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//二维构造初始化</span></span></span><br><span class="line"><span class="function">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));<span class="comment">//二维构造</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector容器构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">11</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4)</span></span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/mfyTFxLJAtRb153.png" alt="vector容器构造.png">  </p>
<h2 id="3、赋值操作"><a href="#3、赋值操作" class="headerlink" title="3、赋值操作"></a>3、赋值操作</h2><p>(1)功能：给vector容器赋值<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> vector&amp; <span class="keyword">operator</span> = (<span class="type">const</span> vector &amp;vec);<span class="comment">//重载等号运算符</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>())用assign来区间赋值</span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">assign</span>(n, elem)，将n个elem拷贝赋值给元素</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2 = v1;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/dRQ9XNxUPz4Gke1.png" alt="vector赋值操作.png"></p>
<h2 id="4、容量和大小"><a href="#4、容量和大小" class="headerlink" title="4、容量和大小"></a>4、容量和大小</h2><p>(1)功能：对vector容器进行容量和大小的操作<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> v.<span class="built_in">empty</span>();<span class="comment">//用来判空</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">capacity</span>();<span class="comment">//用来获取容器中元素个数的大小</span></span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">size</span>();<span class="comment">//用来获取容器当前元素个数</span></span><br><span class="line"><span class="number">4.</span> v.<span class="built_in">resize</span>(<span class="type">int</span> num);<span class="comment">//用来重新指定容器的长度,如果变短则阶段删除</span></span><br><span class="line"><span class="number">5.</span> v.<span class="built_in">resize</span>(<span class="type">int</span> num, <span class="type">int</span> elem);<span class="comment">//用来重新指定容器的长度，并以elem来填充</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量、大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;capacity容量：&quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v1的大小为：&quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新指定大小</span></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">14</span>);  <span class="comment">//如果重新指定的比原来长了，默认用0填充新的位置</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">11</span>, <span class="number">45</span>);  <span class="comment">//重载，参数2可以指定默认填充值</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">        v1.<span class="built_in">resize</span>(<span class="number">4</span>);  <span class="comment">//如果重新指定的比原来短了，超出的部分会被截断</span></span><br><span class="line">        <span class="built_in">printVector</span>(v1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/asJfFOLiZrRQhkb.png" alt="vector容量和大小.png"></p>
<p><strong>补充：</strong>  </p>
<ul>
<li>vector中的capacity指的是容量，即在不分配更多内存的情况下，可以保存的最多个数，而size则是当前容器的大小。</li>
<li><strong>size 总是小于或等于 capacity</strong></li>
<li>当容器中的size &#x3D;&#x3D; capacity时,此时再向其中插入内容的话，则vector会申请出更多的空间。</li>
<li><strong>申请空间时不是直接在原来的空间上连续往下开辟，而是另找一块更大的空间，完成拷贝操作后，然后把当前vector的指针指向新的更大的空间。</strong></li>
</ul>
<h2 id="5、插入和删除"><a href="#5、插入和删除" class="headerlink" title="5、插入和删除"></a>5、插入和删除</h2><p>(1)功能：往vector容器中插入和删除元素<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> v.<span class="built_in">push_back</span>(ele);<span class="comment">//尾插元素</span></span><br><span class="line"><span class="number">2.</span> v.<span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line"><span class="number">3.</span> v.<span class="built_in">insert</span>(const_iterator pos, ele);<span class="comment">//在迭代器指向位置pos处插入元素ele</span></span><br><span class="line"><span class="number">4.</span> v.<span class="built_in">insert</span>(const_iterator  pos, count, ele);<span class="comment">//在指定位置pos插入count个元素</span></span><br><span class="line"><span class="number">5.</span> v.<span class="built_in">erase</span>(const_iterator  pos);<span class="comment">//删除迭代器指向位置的元素</span></span><br><span class="line"><span class="number">6.</span> v.<span class="built_in">erase</span>(const_iterator  start, const_iterator end);<span class="comment">//删除迭代器从start到end之间的元素</span></span><br><span class="line"><span class="number">7.</span> v.<span class="built_in">clear</span>();<span class="comment">//删除容器中所有的元素</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="comment">//尾插</span></span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(<span class="number">14</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删</span></span><br><span class="line">    v1.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">114</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定位置指定数量插入</span></span><br><span class="line">    v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">514</span>);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除区间</span></span><br><span class="line">    v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2清空前：&quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    v2.<span class="built_in">clear</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2清空后: &quot;</span>;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test04</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/XaELBwfKrmn6s4p.png" alt="vector插入和删除.png"></p>
<h2 id="6、数据存取操作"><a href="#6、数据存取操作" class="headerlink" title="6、数据存取操作"></a>6、数据存取操作</h2><p>(1)功能：对vector中的数据进行存储和拿取操作。<br>(2)方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">operator</span>[index];<span class="comment">//类似数组中的[]，返回索引index所指向的数据</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">at</span>(<span class="type">int</span> index);<span class="comment">//用at函数来返回索引index所指向的数据</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">front</span>();<span class="comment">//返回容器中的第一个数据</span></span><br><span class="line"><span class="number">4.</span> <span class="built_in">back</span>();<span class="comment">//返回容器中最后一个元素</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用[]的方式访问数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用at的方式访问数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素为：&quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最后一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test05</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/HiO7dISFB4WbkVj.png" alt="vector数据存取.png"></p>
<h2 id="7、互换容器"><a href="#7、互换容器" class="headerlink" title="7、互换容器"></a>7、互换容器</h2><p>(1)功能：将两个容器的元素进行交换<br>(2)方式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v1.<span class="built_in">swap</span>(v2);<span class="comment">//将v2的元素与v1元素互换</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test06</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/zQwTGWjLyrKCdqk.png" alt="vector互换容器.png"></p>
<p><strong>补充（重要用途）：</strong><br>我们可以使用swap来使两个容器互换，加之匿名对象的性质，可以用来达到<strong>收缩内存空间</strong>的目的。方式如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果单重新指定大小的话，容量并没有变,导致多余的空间浪费</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">25</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用resize(): &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//而我们可以巧用swap()来收缩内存</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">//vector&lt;int&gt;(v)创建了一个匿名对象，会按照v大的大小初始化这个匿名对象容器的大小</span></span><br><span class="line">                                  <span class="comment">//用swap()会将其与匿名函数进行交换，原容器的指针指向匿名对象的容器，原指向匿名对象容器的指针指向原容器</span></span><br><span class="line">                                  <span class="comment">//系统创建完匿名函数后会对匿名对象的指针（地址、内存）进行回收</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用swap+匿名函数: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test07</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/6zufVWerAqth4LZ.png" alt="vector收缩内存空间.png"></p>
<h2 id="8、预留空间"><a href="#8、预留空间" class="headerlink" title="8、预留空间"></a>8、预留空间</h2><p>（1）功能：预先开辟空间，减少vector在动态扩展容量时的扩展次数。<br>（2）方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reserve</span>(<span class="type">int</span> len);<span class="comment">//容器预留len个元素长度,预留位置不初始化,元素不可访问</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test08</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++)&#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每扩容一次就会新开一块内存，则p指向的地址与原来的不同，以此来统计动态开辟的次数。</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != &amp;v1[<span class="number">0</span>]) &#123;</span><br><span class="line">            p1 = &amp;v1[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;不预留空间时count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">reserve</span>(<span class="number">114514</span>);</span><br><span class="line">    <span class="type">int</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">114514</span>; i++) &#123;</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (p2 != &amp;v2[<span class="number">0</span>]) &#123;</span><br><span class="line">            p2 = &amp;v2[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;预留空间时count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test08</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<p><img src="https://s2.loli.net/2023/11/11/ypYEBs6Q4ITXuJw.png" alt="vector预留空间.png"></p>
<h2 id="vector小结"><a href="#vector小结" class="headerlink" title="vector小结"></a>vector小结</h2><ul>
<li>vector容器是最常用的容器之一，大多时候需要用它来存储数据。</li>
<li>构造函数，元素访问，二维容器，遍历获取，插入删除等操作比较常见。</li>
<li>基础常用的是用[]来获取，访问，构造匿名构造和指定大小构造用得较多，push_back()也用的较多。</li>
<li>注意迭代器的访问，因为它能直接指向内存，且较灵活。</li>
<li>构造、赋值操作中的内存原理需要掌握，扩容时机制是重新开一块新的空间，指针重新指向。</li>
<li>匿名对象的地址、内存会被系统自动回收，因此可以巧用swap和匿名对象来收缩空间，另外注意一下预留空间能减少动态扩容开辟次数。</li>
</ul>
<blockquote>
<p>以上就是关于vector容器常见操作和原理的全部内容了，如果文章有什么错误或者遇到什么问题，欢迎随时和我交流联系。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>first</title>
    <url>/2022/10/09/first/</url>
    <content><![CDATA[<p>不要强求不可知，要从已知推未知。</p>
]]></content>
  </entry>
  <entry>
    <title>git历险记(持续更新ing)</title>
    <url>/2025/08/11/git%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/03/30/1nQkwjTGWZaVMIo.png">  </p>
<hr>
<p>十年工程师：好，欢迎加入idjatsni公司，你先熟悉一下，调整调整<br>小灯：okok    </p>
<p>在工作中，git已然成为一项必备技能，git虽然看起来不像其他知识那样复杂，但是想要用好git也不是一件容易的事情，当面对的团队合作项目越来越复杂时，当在职场种摸爬滚打也越来越久时，我们必然会碰到各种各样的团队协作问题。</p>
<span id="more"></span>  
<p>面对各种情景，如果不知道如何处理，则会拖慢整体开发效率，甚至无法完成开发。基于此，我站在一个基础初学者的角度，结合个人工作中经常碰到的各种情形，整理出这份面向场景的git使用方案，暂且称它为“git历险记吧”</p>
<hr>
<p>前言：先学习一些基础概念，比如git是什么，分支是什么，节点是什么等。推荐基础资料学习：  </p>
<blockquote>
<p>我的博客：《git入门实践（入门）》<br>动画网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a><br>other</p>
</blockquote>
<p>首先先申请公司各种账号，这里主要是代码托管平台的账号，比如gitlab上的，根据公司步骤来即可</p>
<h1 id="s1-安装git"><a href="#s1-安装git" class="headerlink" title="s1. 安装git"></a>s1. 安装git</h1><ul>
<li>mac环境</li>
</ul>
<ol>
<li>先安装Homebrew，官网下载，或者终端执行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>打开终端执行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>windows环境</li>
</ul>
<ol>
<li>访问官网下载安装包：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li>
<li>下载后运行安装程序，默认选项一般都可以直接下一步。</li>
</ol>
<ul>
<li>检查环境<br>安装好后，终端运行  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">    git --version</span><br><span class="line">    ```  </span><br><span class="line">    显示版本号即安装成功  </span><br><span class="line"></span><br><span class="line">-- --</span><br><span class="line"><span class="comment"># s2. 最小配置</span></span><br><span class="line">最小配置，要配置用户名和邮箱，在命令行中：    </span><br><span class="line"> ```sh</span><br><span class="line">    git config global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">    git config global user.email <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br><span class="line">```    </span><br><span class="line">然后执行命令查看生效:</span><br><span class="line">```sh</span><br><span class="line">    git config --global --list</span><br></pre></td></tr></table></figure>
若显示出user.name和user.email，则配置成功  <blockquote>
<p>PS: 这里的global参数指的是配置在当前用户生效，也就是该用户所有仓库生效，另外还有local，system</p>
</blockquote>
</li>
</ul>
<p>三种配置作用范围：</p>
<ul>
<li>local： 仅当前仓库生效</li>
<li>global： 当前用户在所有仓库生效</li>
<li>system： 系统所有用户和仓库生效</li>
</ul>
<p>优先级: system -&gt; global -&gt; local</p>
<h1 id="s3-配置公私钥"><a href="#s3-配置公私钥" class="headerlink" title="s3. 配置公私钥"></a>s3. 配置公私钥</h1><p>配置公私钥来让传输更快速和安全，现在应该是必备的了</p>
<ol>
<li><p>生成ssh key并复制</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;你的邮箱@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p> 执行完后会生成一个公钥和一个私钥,分别在：</p>
<blockquote>
<p>~&#x2F;.ssh&#x2F;id_ed25519 (私钥，得保管好)<br>~&#x2F;.ssh&#x2F;id_ed25519.pub （公钥）  </p>
</blockquote>
</li>
<li><p>然后把公钥的内容复制，放到远程代码托管平台的制定公钥位置上，比如github、gitlab、gitee，看公司用的是什么，然后测试连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>对于这里的“<a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>”，一般公司都有自己的制定地址名称，替换即可。成功的话，会看到：Hi username!</p>
</li>
</ol>
<h1 id="s4-xxx-permission-denied"><a href="#s4-xxx-permission-denied" class="headerlink" title="s4. xxx permission denied"></a>s4. xxx permission denied</h1><p>假如碰上这个提示，一般就是权限不够，找对应仓库的负责人或者有权限的管理者，帮开通权限</p>
<h1 id="s5-配置新项目环境"><a href="#s5-配置新项目环境" class="headerlink" title="s5. 配置新项目环境"></a>s5. 配置新项目环境</h1><p>一般项目配置都会有文档教程，按照文档优先配置，可以去问对应的十年工程师，常规步骤</p>
<ol>
<li><p>克隆项目到本地，命令输入</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/16/AXnfSDuvjbZsNIB.png" alt="repoAdress.png"><br> 如上述就可以用ssh的，执行：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:bistukk/kkMusic.git</span><br></pre></td></tr></table></figure>
<p> 执行完后，项目就会顺利clone到本地    </p>
</li>
<li><p>如果项目是用子仓库嵌套的方式组织的话，那应该还需要执行</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive --progress</span><br></pre></td></tr></table></figure>
<p> 这将会拉取所有子模块代码并更新到最新版本（关于submodule，后面会详细讲到）  </p>
</li>
<li><p>切换到指定分支</p>
<ul>
<li>查看当前分支  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure>
  这将会列出你当前本地所在的分支, 后面可以加-a参数，-r参数，-v参数，表示所有，远程，详细信息</li>
<li>查看当前节点  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li>
<li>切换到指定分支（本地没有，远端有）  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git switch -c &lt;本地分支名&gt; origin/&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></li>
<li>如果有子模块有特定分支需要切换，则手动进入子模块目录，执行切换分支操作</li>
</ul>
</li>
</ol>
<p>自此，如果合理按照文档的配置，并且已经切换到对应的分支节点了，项目一般就能编译运行了，接下来进入开发,进入之前先来了解git的几个区域</p>
<h1 id="s6-工作区，暂存区，本地仓库，远程仓库"><a href="#s6-工作区，暂存区，本地仓库，远程仓库" class="headerlink" title="s6. 工作区，暂存区，本地仓库，远程仓库"></a>s6. 工作区，暂存区，本地仓库，远程仓库</h1><p>首先要先知道git的工作流转有这四个区域</p>
<ol>
<li>工作区(Working Directory)<br> 工作区其实就是项目clone下来后的文件地方内容，平时看到、编辑文件的目录<br> 修改的文件最开始都是在工作区。</li>
<li>暂存区（taging Area &#x2F; Index）<br> git add 会把工作区的修改放到这里，准备提交<br> 可以理解为“提交前的缓冲区”，将工作区的东西放入在暂存区： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li>
<li>本地仓库（Local Repository &#x2F; HEAD 所指向的仓库）<br> 保存了提交历史（commit），git commit 会把暂存区内容提交到本地仓库。HEAD 指向当前分支的最新提交，通过git commit将暂存区的内容提交到本地仓库 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m<span class="string">&quot;本次修改内容信息&quot;</span></span><br></pre></td></tr></table></figure>
 这将会再本地仓库生成一个提交记录，commit节点</li>
<li>远程仓库<br> 托管在服务器上的仓库，比如 GitHub、GitLab、公司自建 Git 服务器。本地仓库通过网络与远程仓库同步。保存了所有共享历史，供团队协作使用。用git push将本地仓库的内容推送到远端关联仓库 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
一定要牢记有这四个区域，虽然很简单，但是后续很多命令其实都需要对区域有清楚的划分。接下来进入场景篇，顺序难度不分先后，start adventure</li>
</ol>
<h1 id="s7-在基线分支进行了修改，想开新的分支并包含此次内容，并在新开分支上开发"><a href="#s7-在基线分支进行了修改，想开新的分支并包含此次内容，并在新开分支上开发" class="headerlink" title="s7. 在基线分支进行了修改，想开新的分支并包含此次内容，并在新开分支上开发"></a>s7. 在基线分支进行了修改，想开新的分支并包含此次内容，并在新开分支上开发</h1><ol>
<li>改动尚未commit（仍在工作区&#x2F;暂存区） <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建并切换到新分支，改动自动跟过来</span></span><br><span class="line">git switch -c feature/new-branch</span><br><span class="line"><span class="comment"># 或者较旧版本 Git</span></span><br><span class="line">git checkout -b feature/new-branch</span><br></pre></td></tr></table></figure>
 然后就直接在feature&#x2F;new-branch 上继续开发，baseline 保持原状。</li>
<li>改动已 commit 但还没 push 到远端<br> 先把 commit 带到新分支，再把 baseline 分支回退<ul>
<li>新开分支并保留改动 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git switch -c feature/new-branch        <span class="comment"># 新分支里已有那些 commit</span></span><br></pre></td></tr></table></figure></li>
<li>切回 baseline 并撤掉那些 commit <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git switch baseline</span><br><span class="line">git reset --hard origin/baseline </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>改动已 push 到远端，但希望从 baseline 分支“分离”出来<br>建议保持 baseline 历史不动，直接从对应 commit 打出新分支即可，然后跟团队成员交流baseline如何处理 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从含有改动的最新提交打新分支</span></span><br><span class="line">git switch -c feature/new-branch</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="S8-想把某个commit节点应用到另一个某个分支节点上"><a href="#S8-想把某个commit节点应用到另一个某个分支节点上" class="headerlink" title="S8. 想把某个commit节点应用到另一个某个分支节点上"></a>S8. 想把某个commit节点应用到另一个某个分支节点上</h1><p>1.假设在分支 A 上开发了某个功能，有一个 commit 想要应用到分支 B 上。</p>
<ul>
<li><p>查看要 pick 的 commit：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout A</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure>
<p>  找到要挑选的 commit，比如：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a1b2c3d 修复了音频播放的 bug</span><br></pre></td></tr></table></figure></li>
<li><p>切换到目标分支 B，然后cherry-pick</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout B</span><br><span class="line">git cherry-pick a1b2c3d</span><br></pre></td></tr></table></figure>
<p>2.如果commit较多，可以：</p>
</li>
<li><p>多个commit（不一定连续）</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git cherry-pick hash1 hash2 hash3 ...</span><br></pre></td></tr></table></figure></li>
<li><p>多个连续 commit</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git cherry-pick hash1^..hash3</span><br></pre></td></tr></table></figure>
<p>3.如果有冲突，需要解决，解决完后：  </p>
<p>  git add .<br>  git cherry-pick –continue</p>
</li>
</ul>
<h1 id="s9-在自己的开发分支上进行了一些开发，这时候基线分支已经有很多更新"><a href="#s9-在自己的开发分支上进行了一些开发，这时候基线分支已经有很多更新" class="headerlink" title="s9. 在自己的开发分支上进行了一些开发，这时候基线分支已经有很多更新"></a>s9. 在自己的开发分支上进行了一些开发，这时候基线分支已经有很多更新</h1><p>两种情况，一个是还打算继续在个人分支上开发，一个是直接到基线分支开发（迭代快，时间紧的时候）</p>
<ol>
<li>继续在个人分支上开发（个人长期开发，时间足够）<ul>
<li><p>方法一：使用 rebase  </p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先切到自己的开发分支</span></span><br><span class="line">git switch feature/my-dev-branch</span><br><span class="line"><span class="comment"># 把基线分支的最新提交“挪到”当前分支的底部（线性历史）</span></span><br><span class="line">git fetch origin  <span class="comment"># 确保是最新</span></span><br><span class="line">git rebase origin/baseline</span><br></pre></td></tr></table></figure>
<p>  提交会像“从基线上重新开发”一样排到最新更新之后。历史干净线性，适合个人分支开发</p>
</li>
<li><p>方法二：使用 merge（保留开发历史）</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仍然在自己的开发分支</span></span><br><span class="line">git fetch origin</span><br><span class="line">git merge origin/baseline</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>直接到基线分支开发（迭代快，时间紧的时候）<ul>
<li>切换到基线分支并确保是最新的  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git switch baseline</span><br><span class="line">git pull origin baseline  <span class="comment"># 拉取远端最新的 baseline</span></span><br></pre></td></tr></table></figure></li>
<li>从原来的分支 cherry-pick 提交<ul>
<li>情况 A：只想 cherry-pick 最近的 某些次提交<br>  先用git log 找到要 pick 的 commit hash：  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">    git <span class="built_in">log</span> --oneline feature/my-dev-branch</span><br><span class="line">    ```  </span><br><span class="line"></span><br><span class="line">    然后cherry-pick想要的commit_hash:</span><br><span class="line">    ```sh</span><br><span class="line">    git cherry-pick &lt;commit_hash1&gt; &lt;commit_hash2&gt; ...</span><br><span class="line">    ```  </span><br><span class="line">- 情况 B：cherry-pick 一段连续的提交（可以用范围）</span><br><span class="line">    假设想把从 A 到 B 的一段提交 pick 到 baseline 上：</span><br><span class="line">    ```sh</span><br><span class="line">    git cherry-pick A^..B</span><br></pre></td></tr></table></figure>
  注意：这是一个闭区间，包含 A 和 B。</li>
</ul>
</li>
<li>第 3 步：解决冲突（如有）</li>
</ul>
</li>
</ol>
<h1 id="s10-commit了多次，想把多次commit合并成一个"><a href="#s10-commit了多次，想把多次commit合并成一个" class="headerlink" title="s10. commit了多次，想把多次commit合并成一个"></a>s10. commit了多次，想把多次commit合并成一个</h1><p>假设想合并最近的 3 次提交，则可以：<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><br> 然后会进入这样的编辑界面，类似：<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pick 1234567 commit message 1</span><br><span class="line">pick 89abcde commit message 2</span><br><span class="line">pick fedcba9 commit message 3</span><br></pre></td></tr></table></figure><br> 将上面的内容修改为如下形式（除了第一个，其他都改为 squash 或简写 s）<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pick 1234567 commit message 1</span><br><span class="line">squash 89abcde commit message 2</span><br><span class="line">squash fedcba9 commit message 3</span><br></pre></td></tr></table></figure><br> 执行后 Git 会让你编辑 commit message，比如：<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># This is a combination of 3 commits.</span></span><br><span class="line"><span class="comment"># The first commit&#x27;s message is:</span></span><br><span class="line">fix login bug</span><br><span class="line"></span><br><span class="line"><span class="comment"># The 2nd commit message:</span></span><br><span class="line">update UI layout</span><br><span class="line"></span><br><span class="line"><span class="comment"># The 3rd commit message:</span></span><br><span class="line">improve performance</span><br></pre></td></tr></table></figure><br>自己改写为一个清晰的合并提交信息，然后保存退出即可</p>
<ul>
<li>推送变更（如果之前已经推送过这些 commit，需要强推）  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin 分支名 --force（强推时需要force）</span><br></pre></td></tr></table></figure>
  <mark>PS：谨慎使用 –force，因为这会改写历史，其他人基于你这分支工作的话可能会有问题。<br>  建议只在 尚未合并到主分支 或 自己一个人工作的分支 上这么做。<mark></mark></mark></li>
</ul>
<h1 id="s11-自己在本地开发编译运行，检查git发现除了自己的修改外还有很多变更"><a href="#s11-自己在本地开发编译运行，检查git发现除了自己的修改外还有很多变更" class="headerlink" title="s11. 自己在本地开发编译运行，检查git发现除了自己的修改外还有很多变更"></a>s11. 自己在本地开发编译运行，检查git发现除了自己的修改外还有很多变更</h1><p>比如经常：  </p>
<p><img src="https://s2.loli.net/2025/08/16/I49ATW8XEZlqrK2.png" alt="change.png"></p>
<ul>
<li>可能的原因<ol>
<li>编译生成的临时文件 &#x2F; 缓存文件未加入 .gitignore<ul>
<li>▪	比如：*.o, *.class, build&#x2F;, .gradle&#x2F;, DerivedData&#x2F; 等。</li>
<li>▪	常见于 C++、Java、Android、iOS 项目。</li>
</ul>
</li>
<li>IDE 或构建工具自动生成的配置文件<ul>
<li>▪	比如：xcuserdata&#x2F;, .idea&#x2F;, .vscode&#x2F;, .DS_Store。</li>
</ul>
</li>
<li>pod install &#x2F; gradle sync &#x2F; CMake configure 等拉取依赖引起的变更<ul>
<li>▪	例如 iOS 的 .xcworkspace 或 Pods 文件夹，Android 的 .gradle、*.iml 文件等。</li>
</ul>
</li>
<li>代码格式化工具自动修改了代码<ul>
<li>▪	例如 clang-format, prettier, ktlint 自动调整了自己没关注的文件。</li>
</ul>
</li>
</ol>
</li>
<li>解决方案：<ol>
<li>方式一：将无关文件添加到 .gitignore。<br>  比如看到的 build&#x2F;, .idea&#x2F;, Pods&#x2F;, *.pbxuser 等变动，可以在根目录的 .gitignore 文件中加： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iOS</span></span><br><span class="line">*.xcuserdatad</span><br><span class="line">*.xcscmblueprint</span><br><span class="line">*.pbxuser</span><br><span class="line">*.mode1v3</span><br><span class="line">*.mode2v3</span><br><span class="line">DerivedData/</span><br><span class="line">Pods/</span><br><span class="line"><span class="comment"># Android</span></span><br><span class="line">*.iml</span><br><span class="line">.gradle/</span><br><span class="line">build/</span><br><span class="line">.idea/</span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure>
 然后执行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git restore --staged &lt;文件名&gt;     <span class="comment"># 如果已经被 add</span></span><br><span class="line">git restore &lt;文件名&gt;              <span class="comment"># 恢复修改</span></span><br></pre></td></tr></table></figure></li>
<li>方式二：只 add 实际改动的文件   <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add 文件1 文件2 文件3</span><br><span class="line">git commit -m <span class="string">&quot;只提交你需要的内容&quot;</span></span><br></pre></td></tr></table></figure>
 建议用 git diff &#x2F; git status 仔细检查后再 git add。</li>
</ol>
</li>
</ul>
<h1 id="s12-Git-hook"><a href="#s12-Git-hook" class="headerlink" title="s12. Git hook"></a>s12. Git hook</h1><p>&amp;emsp; “Git Hook”这个名字里的“Hook”，来源于计算机编程中的“hook”概念，意思是“钩子”或“挂钩”。<br>&amp;emsp; Git hook 是放在 .git&#x2F;hooks&#x2F; 目录下的一组脚本文件（Linux&#x2F;Mac 是 shell 脚本，Windows 也可以是 batch 脚本或其他可执行文件）。<br>&amp;emsp; 每个 hook 脚本对应 Git 操作的某个阶段，比如提交前、提交后、推送前等。<br>&amp;emsp; 默认目录下有很多示例脚本，文件名一般是钩子的名字（比如 pre-commit、commit-msg 等），但默认都是 .sample 后缀，需要去掉 .sample 并确保可执行，才能生效。<br>比如：<br>    <img src="/.io//image-19.png" alt="alt text">  </p>
<p> 比如在pre-commit中，可以有：<br> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 简单示例：禁止提交包含 TODO 的代码</span></span><br><span class="line"><span class="keyword">if</span> git diff --cached | grep -q <span class="string">&#x27;TODO&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Error: Commit contains TODO.&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><br> 给脚本加权限：chmod +x .git&#x2F;hooks&#x2F;pre-commit<br> 测试提交时，如果暂存区的变更里包含 TODO，提交会被阻止。</p>
<p> <strong>实战例子</strong><br> 别人的一些功能别人没有适配也会影响到分支导致无法commit<br> 应对方案，可以把git hook关了，命令行可在commit的时候手动加上 –no-verify<br>或者图形界面设置(比如在android studio里)</p>
<h1 id="s13-submodule相关"><a href="#s13-submodule相关" class="headerlink" title="s13. submodule相关"></a>s13. submodule相关</h1><p>在 Git 中，submodule（子模块）是一个 Git 仓库中的嵌套仓库。当你想在一个 Git 仓库中引用另一个独立的 Git 仓库（比如作为依赖库），就可以使用 submodule。  </p>
<p>&amp;emsp;<strong>子模块的特点</strong></p>
<ul>
<li>子模块不随主仓库自动更新：它只是记录了一个特定的提交（commit）引用。</li>
<li>更新子模块需要手动执行；</li>
<li>删除子模块比普通文件稍复杂（因为有多个配置项需要清理）；</li>
</ul>
<ol>
<li><p>更新子仓库  </p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive --progress</span><br></pre></td></tr></table></figure>
<p> 这将会把所有子仓库更新到最新的提交引用，加上–progress可以查看进度，避免卡太久不知道什么情况。</p>
</li>
<li><p>有时需要特定版本的子仓库，则在执行更新子仓库后，需要自己切进特定分支，切换对应的分支节点。</p>
</li>
<li><p>注意，子仓库有变更，主项目如果需要应该子仓库变更的节点的话，也应该提交变更的子仓库节点引用</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>STL解析</title>
    <url>/2023/11/07/STL%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="C-中的神兵利器-——-STL"><a href="#C-中的神兵利器-——-STL" class="headerlink" title="C++中的神兵利器 —— STL"></a>C++中的神兵利器 —— STL</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>STL是C++开发学习中的重要一环，因为它使得我们在开发过程中能够更便捷、高效地实现我们想要的操作。此前我也系统地学过了一遍STL，这些天再次学习回顾，发现了不少新东西，于是乎我决定把一些重要的知识点以及自己的理解总结记录下来，下面我们一起来学习交流吧。</p>
<h2 id="STL介绍"><a href="#STL介绍" class="headerlink" title="STL介绍"></a>STL介绍</h2><ul>
<li>STL（Standard Template Library），其实就是标准模板库，其中包含有大量的模板类和模板函数，可以供C++的开发者使用，其高效、便捷、安全可靠。</li>
<li>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</li>
<li>通俗的来说，STL其实就是一些容器、算法及其他的一些组件的集合，是一个很棒的库，有了这个库，我们就可以直接使用、调用这个库里的东西来完成一些操作，就不用再重复造一些轮子了，大大提高了开发效率，这也是为什么STL在C++编程中重要的原因。</li>
</ul>
<h2 id="六大组件"><a href="#六大组件" class="headerlink" title="六大组件"></a>六大组件</h2><p>STL的设计思想是将数据结构和算法进行分离，使得他们可以独立使用和扩展，提高了代码的复用性和可读性。<br>STL主要包含六大组件：</p>
<ul>
<li><strong>容器（Containers）</strong>：如动态数组（vector）、链表（list）、双端队列(deque)、对（pair）、<br>映射(map)、集合（set）等</li>
<li><strong>算法（Algorithms）</strong>：如排序、查找、合并、计数等。</li>
<li><strong>迭代器（Iterator）</strong>：是一种抽象的数据类型，可用于访问容器中的元素，STL中的五种迭代器：输入迭代器（Input Iterator）、输出迭代器（Output Iterator）、前向迭代器（Forward Iterator）、双向迭代器（Bidirectional Iterator）和随机访问迭代器（Random Access Iterator）</li>
<li><strong>仿函数（Functor）</strong>：就是使一个类的使用看上去像一个函数。如加减乘除、大小比较等</li>
<li><strong>适配器（Adaptor）</strong>：其实就是一种基于基础容器来实现的一些带有特定功能的容器模板类。如stack、queue、priority_queue等、</li>
<li><strong>空间配置器（Allocator）</strong>：用得最少的，但是它总是隐藏在一切组件的背后，默默工作。通俗的说，整个STL的操作对象都存放在容器之中（vertor、list），而容器一定需要配置空间以放置资料，这就是空间配置器的作用。</li>
</ul>
<h2 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h2><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="补充：C-标准库中的String类"><a href="#补充：C-标准库中的String类" class="headerlink" title="补充：C++标准库中的String类"></a>补充：C++标准库中的String类</h3><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a><strong>关联式容器</strong></h3><h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h2 id="三、迭代器"><a href="#三、迭代器" class="headerlink" title="三、迭代器"></a>三、迭代器</h2><h2 id="四、仿函数"><a href="#四、仿函数" class="headerlink" title="四、仿函数"></a>四、仿函数</h2><h2 id="五、适配器"><a href="#五、适配器" class="headerlink" title="五、适配器"></a>五、适配器</h2><h2 id="六、空间配置器"><a href="#六、空间配置器" class="headerlink" title="六、空间配置器"></a>六、空间配置器</h2>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>git学习与实践（入门）</title>
    <url>/2024/03/30/git%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
    <content><![CDATA[<h1 id="git学习与实践（入门）"><a href="#git学习与实践（入门）" class="headerlink" title="git学习与实践（入门）"></a>git学习与实践（入门）</h1><h2 id="一、git介绍"><a href="#一、git介绍" class="headerlink" title="一、git介绍"></a>一、git介绍</h2><p><strong>什么是git?</strong><br>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.<br><img src="https://s2.loli.net/2024/03/30/1nQkwjTGWZaVMIo.png" alt="git.png"><br>这是Git官网的介绍，Git 是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小到大的项目。</p>
<span id="more"></span> 
<p><strong>那什么是版本控制系统？</strong><br>当我们用作业本区写作业时，可能会发生一些情况：如写错字，更改作业内容，复习之前已写过并修改过的内容等。而版本控制就相当于有一个自动帮你记录这些情况和操作的工具，你可以通过这个工具很快找到这些修改与变动的记录并执行一些操作如回滚，恢复，修改，合并等。其实顾名思义，就是用来控制“版本”的，而这个版本也就是你做出的一些操作导致文件发生的变动，用Git就能很好地管理这些变动。<br><strong>集中式与分布式</strong><br>其实版本控制系统在Git出现之前，几乎都是集中式的，如CVS及SVN都是集中式的版本控制系统。集中式版本控制系统，版本库是集中存放在中央服务器的，且需联网才能工作。而分布式版本控制系统是每个人电脑里都有一个版本库，且不需要联网就能工作，这样提高了工作效率与安全性，Git就是一个强大的分布式版本控制系统。</p>
<h2 id="二、简单流程"><a href="#二、简单流程" class="headerlink" title="二、简单流程"></a>二、简单流程</h2><ul>
<li><p>首先得在操作系统中装上Git,这个直接去官网下载就好  </p>
</li>
<li><p>Linux用户用命令即可安装：</p>
<blockquote>
<p>sudo apt-get install git</p>
</blockquote>
</li>
<li><p>MAC用户可以通过XCode安装  </p>
</li>
<li><p>安装完成后，需要最在命令行输入进行设置：</p>
<blockquote>
<p>git config –global user.name “Your Name”</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>git config –global user.email “<a href="mailto:&#x65;&#109;&#97;&#105;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#99;&#111;&#109;">&#x65;&#109;&#97;&#105;&#x6c;&#64;&#101;&#x78;&#97;&#109;&#x70;&#108;&#x65;&#46;&#99;&#111;&#109;</a>“</p>
</blockquote>
<h3 id="1、简单例子"><a href="#1、简单例子" class="headerlink" title="1、简单例子"></a>1、简单例子</h3><p>其实最基础也是最重要的指令也就那几条，我们可以通过一个例子完成：<br><strong>将本地的一个txt文件上传到远程仓库</strong><br>（1）在代码托管平台创建一个仓库（以Github为例）, 登录GitHub，点击页面右上角的加号图标，选择“New repository”创建一个新的仓库，并按照提示填写相关信息。  </p>
<p>（2）在一个目录下创建一个Git版本库（仓库）,这将把当前目录变为Git可以管理的仓库</p>
<blockquote>
<p>git init  </p>
</blockquote>
<p>（3）在当前目录下编写一个readme.txt文件,然后用 git add 命令将文件添加到暂存区</p>
<blockquote>
<p>git add readme.txt</p>
</blockquote>
<p>（4）用 git commit 命令把文件提交到仓库</p>
<blockquote>
<p>git commit -m “wrote a readme file”</p>
</blockquote>
<p>（5）确认分支，现在默认是main</p>
<blockquote>
<p>git branch -M main</p>
</blockquote>
<p>（6）关联本地仓库和远程仓库： 在GitHub上创建的远程仓库有一个URL，复制该URL。然后，在命令行或终端中执行以下命令，将本地仓库与远程仓库关联起来</p>
<blockquote>
<p>git remote add origin &lt;远程仓库URL&gt;</p>
</blockquote>
<p>（7）推送到远程仓库： 最后，使用以下命令将本地仓库的内容推送到GitHub的远程仓库</p>
<blockquote>
<p>git push -u origin main</p>
</blockquote>
<p>如果按照以上操作执行的话，那么不出意外readme.txt文件将成功被传上Github上。<br>当然我们在执行这样一个流程操作时肯定会遇到各种各样的问题，我建议还是自己去试一试，把自己的项目，学习资源等东西试着传到Github上，然后这个过程中把遇到的问题解决并记录下来（也许会遇到各种问题，且解决起来可能比较耗时），但这样操作几遍过后其实就基本能掌握了。</p>
<h3 id="2、基本理论"><a href="#2、基本理论" class="headerlink" title="2、基本理论"></a>2、基本理论</h3><p>Git虽然常用到的命令并不复杂，但是我们了解一下这个东西的一些基本理论，那将有助于我们更好地使用这个工具。<br><strong>四个工作分区</strong></p>
<ul>
<li>工作目录(Working Directory): 电脑中存放代码修改文件的地方。当我们执行命令**git </li>
<li>暂存区(Stage&#x2F;Index): 存放临时改动，前面的命令<strong>git add</strong>就是就是将内容添加到暂存区</li>
<li>仓库区(Repository或Git Directory): 安全存放数据的地方，里面有所有你提交的版本数据，指向最新放入仓库的指针叫HEAD。执行<strong>git commit</strong>命令后就是提交到这里</li>
<li>远程仓库(Remote Directory): 远程托管代码的服务器，其实就是一台一直开着的电脑，里面面也有同样一份仓库来存放你的代码数据。执行<strong>git push</strong>命令后就是推送到远程仓库</li>
</ul>
<h2 id="三、常见功能操作"><a href="#三、常见功能操作" class="headerlink" title="三、常见功能操作"></a>三、常见功能操作</h2><h3 id="1-时空穿梭"><a href="#1-时空穿梭" class="headerlink" title="1.时空穿梭"></a>1.时空穿梭</h3><p>支持版本回滚，管理修改，撤销修改，删除文件等操作</p>
<ul>
<li>查看历史提交<blockquote>
<p>git log</p>
</blockquote>
</li>
<li>回退到之前的版本<blockquote>
<p>git reset –hard commit_id</p>
</blockquote>
</li>
<li>查看状态<blockquote>
<p>git status</p>
</blockquote>
</li>
<li>撤销修改<blockquote>
<p>git checkout – file</p>
</blockquote>
</li>
</ul>
<h3 id="2-远程仓库"><a href="#2-远程仓库" class="headerlink" title="2.远程仓库"></a>2.远程仓库</h3><ul>
<li>关联远程仓库<blockquote>
<p>git remote add origin git@server-name:path&#x2F;repo-name.git</p>
</blockquote>
</li>
<li>远程提交<blockquote>
<p>git push</p>
</blockquote>
</li>
<li>远程克隆仓库(Git支持多种协议，包括https，但ssh协议速度最快。)<blockquote>
<p>git clone url</p>
</blockquote>
</li>
</ul>
<h3 id="3-分支操作"><a href="#3-分支操作" class="headerlink" title="3.分支操作"></a>3.分支操作</h3><ul>
<li>查看分支<blockquote>
<p>git branch</p>
</blockquote>
</li>
<li>创建分支<blockquote>
<p>git branch name</p>
</blockquote>
</li>
<li>切换分支<blockquote>
<p>git checkout name</p>
</blockquote>
</li>
</ul>
<p>或者</p>
<blockquote>
<p>git switch name  </p>
</blockquote>
<ul>
<li>创建+切换分支<blockquote>
<p>git checkout -b name</p>
</blockquote>
</li>
</ul>
<p>或者</p>
<blockquote>
<p>git switch -c name</p>
</blockquote>
<ul>
<li>删除分支<blockquote>
<p>git branch -d name</p>
</blockquote>
</li>
<li>合并分支<blockquote>
<p>git merge name</p>
</blockquote>
</li>
<li>解决冲突<br>先查看有冲突内容的文件<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容<br>然后手动修改保存后再提交即可<br><strong>查看分支合并图：</strong><blockquote>
<p>git log –graph</p>
</blockquote>
</li>
</ul>
<h3 id="4-自定义"><a href="#4-自定义" class="headerlink" title="4.自定义"></a>4.自定义</h3><ul>
<li>忽略特殊文件<br>Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</li>
<li>配置文件<br>每个仓库的Git配置文件都放在.git&#x2F;config文件中,可以在里面自己配置</li>
<li>搭建git服务器</li>
</ul>
<h2 id="四、小总结"><a href="#四、小总结" class="headerlink" title="四、小总结"></a>四、小总结</h2><p>其实Git就是用来管理控制工作的文件的，在多人合作团队任务中起到非常重要的作用，学会管理，学会协作，能够提高工作的效率，或许也能让一个团队、项目走得更远。</p>
]]></content>
  </entry>
  <entry>
    <title>photos</title>
    <url>/2022/10/15/photos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/11/04/test/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/07/10/fyHQn2XGReotmVg.jpg" alt="阿狸的世界.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/10/13/title/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vscode写markdown文件中的tab缩进错误显示问题</title>
    <url>/2023/11/13/vscode%E5%86%99markdown%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84tab%E7%BC%A9%E8%BF%9B%E9%94%99%E8%AF%AF%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="用vscode写Markdown时tab键在网页上缩进错误问题"><a href="#用vscode写Markdown时tab键在网页上缩进错误问题" class="headerlink" title="用vscode写Markdown时tab键在网页上缩进错误问题"></a>用vscode写Markdown时tab键在网页上缩进错误问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>这两天在写博客时，遇到了一个奇怪的错误，就是在博客上传到网站上预览时，代码块中用tab键缩进的空格变成了8空格。我平时用vscode来编写博客，在本地渲染预览时没有问题，显示为4个空格，然而传到博客网站上时就变成8空格，有些奇怪。</strong>  </p>
<p>博客网站上显示：  </p>
<p><img src="https://s2.loli.net/2023/11/13/kj9Obl71K4of2Ct.png" alt="缩进问题.png"> </p>
<span id="more"></span>  
<p>本地预览：  </p>
<p><img src="https://s2.loli.net/2023/11/13/lxBeuiwbzEYpC5h.png" alt="本地预览.png"> </p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我一开始以为是我的tab-size设置有误，于是我检查了我的tab-size设置，发现并无问题，就是4个空格。<br><img src="https://s2.loli.net/2023/11/13/hgABoUy6LCNMt9W.png" alt="tab-size.png"> </p>
<p>后来我想起之前在编辑微信公众号时使用的秀米排版编辑器遇到的问题，当时首行缩进不能直接用空格，否则会导致排版错误。于是我又检查了是否是因为自己误用空格或空行导致一些格式错误、渲染错误啥的，重新检查打了一遍后，发现网站上显示还是又有问题，看来并不是空格空行导致的。  </p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最终通过查阅资料，解决了这个问题。<br>解决方案如下：  </p>
<ul>
<li>首先打开vscode的命令窗口（在vscode中用快捷键<strong>ctrl + shift + p</strong>）</li>
<li>然后在命令窗口输入convert，会自动弹出下面这两个命令，我们选择<strong>Convert Indentation to Spaces</strong>将tab缩进转为空格命令。</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/13/R1E8nv6CIQuM37Y.png" alt="tab缩进转为空格.png"></p>
<ul>
<li>然后我们在去博客网站上预览，发现成功变回4空格。</li>
</ul>
<p><img src="https://s2.loli.net/2023/11/13/QuPMOV54kwLiB6p.png" alt="tab问题解决后.png">  </p>
<blockquote>
<p>以上问题就成功解决了，成功上传显示无问题后还是挺开心的。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>你曾经加入，我也很感谢你 --2024年终总结</title>
    <url>/2025/01/28/%E4%BD%A0%E6%9B%BE%E7%BB%8F%E5%8A%A0%E5%85%A5%EF%BC%8C%E6%88%91%E4%B9%9F%E5%BE%88%E6%84%9F%E8%B0%A2%E4%BD%A0-2024%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2025/01/28/ZCUt9ORVbHc1gLi.jpg" alt="乌兰察布火山"><br>今天是2024年的最后一天，也就是除夕，明天就是春节了，当然在中国，过年一般都指农历新年。早上起来贴完对子，摆布好房间，还有许多活要干。闲暇之余，对过去的一年做个梳理与总结，回顾过去，展望未来。转眼间，这已是我的第三篇年终总结，我也步入了大三下。</p>
<span id="more"></span>
<h2 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h2><p>岁月不居，时节如流。仿佛昨天还在做着22年高考作文的红楼梦，亦或是留着本手俗手妙手手不如神之一手。而今天就在用着chatgpt梳理着报告与大纲，用豆包撰写着期末论文（当然我是好学生我都是自己写的），头戴vp看着即真实又虚幻的世界，或许还能跟随星舰移民火星。即便如此，在年末之际，puq依旧还是会被横空出世的DeepSeek刷爆。前面排比忘记加上黑神话了，但我依旧想说：“踏上取经路，比抵达灵山更重要”。年终总结要扯一些宏观的东西看起来逼格高点…不过我认为，得与时俱进，抗拒时代的进步，只会落伍。    </p>
<p><img src="https://s2.loli.net/2025/01/28/vUnfOaYQ2mW1Ety.jpg" alt="世纪之交"><br>今年于我而言，依旧没有什么轰轰烈烈，也没有什么刻骨铭心，但是我对世界的看法，对自己的认知确有了更多的思考与角度。</p>
<h3 id="低着头向上看"><a href="#低着头向上看" class="headerlink" title="低着头向上看"></a>低着头向上看</h3><p><img src="https://s2.loli.net/2025/01/28/1erPBm753oEqgCj.jpg" alt="在全北京最大的高校图书馆学习"><br>看了一些书，技术的：《C++新经典》，《Qt6C++开发指南》，《Qt6开发及实例》，《FFmpeg入门详解》、《effective modern C++》等。非技术的如《everyone is PM》，《苦乐参半》，《穷爸爸与富爸爸》，《运营之光：我的互联网运营方法论与自白》，《如何开一家小而美的店》……当然这不是一篇书籍推荐栏目，而于我而言，阅读依旧是获取知识信息的最快且最高效的方式，特别是现在快节奏的时代，网络上的信息良莠不齐，而如何去获取对自己有用的信息，这还挺重要。</p>
<h3 id="activity-amp-competition"><a href="#activity-amp-competition" class="headerlink" title="activity&amp;competition"></a>activity&amp;competition</h3><p><img src="https://s2.loli.net/2025/01/28/1Ut9xYFWXoKV76g.jpg" alt="icpc陕西"><br>当然我也参加了不少活动，诸如“字节跳动2024暑期训练营”，“ICPC国际大学生程序设计竞赛全国邀请赛（陕西）” “2024移动应用创新赛线下专场”，“apple官方校园Club活动”，“开放原子2024春耕校源行专场活动”，“2024wteam创业大咖进校园｜清华大学站 ”，“全国大学生软件创新大赛-软件系统安全赛区域赛”，作为技术负责人参与“2024校园非遗AIGC创作大赛”等，我喜欢参加活动，有些能拿奖品，有些空手而归，但是最重要的是，我参与了，不仅收获了知识与乐趣，也认识了更多志同道合的朋友与伙伴，相互学习，能走的更远。</p>
<h2 id="成长与突破"><a href="#成长与突破" class="headerlink" title="成长与突破"></a>成长与突破</h2><p>2024，我没有拘泥于在校园的安定现状，而是决定出去实习，在准备了一段时间后开启了投递，找实习的过程也不是一帆风顺，有的已读不回石沉大海，有的聊了几句就迎来岗位不适合，当然，最终在经历了多轮的相互抉择后，我最终还是找到了适合我的一份实习。不得不说，做大型项目和个人的小玩具还是不一样的，得考虑的东西很多，代码的构建与管理，团队的合作与分工，接口功能的规范与统一，这与大学的偏理论或者说偏应试的东西差多了，实践才出真知。经过了几个月的历练，我从看不懂代码到主动commit，从愁眉莫展到团队合作，学会看文档，学会请教与交流，我觉得吧，其实实习的过程不仅是学习锻炼技术的过程，更是磨炼个人综合素质的体现。这里也特别感谢我mentor，他教会我很多奇技淫巧，他还说过：“基础是重要的，无论今后去哪，基础是心法”，这句话我也一直记在心上。  </p>
<p><img src="https://s2.loli.net/2025/01/28/SEGhQNKoAIzeprq.jpg" alt="心爱的小桌"><br><img src="https://s2.loli.net/2025/01/28/sd9NJGVTBHqeE7M.jpg" alt="团建"><br>由于我待的公司是一家创业型公司，我也收获了很多创业方面的思维与素质，我想这也是我想要的。有一次团建，销售总监问我说：小伙子不错，有自己的思想，你现在才大三，那你今后打算做什么呢？我记得当时的回答是：“为祖国健康工作50年”，当时大家都乐的笑了起来，虽然我也是笑了，但是我知道，有些东西是发自内心的。而公司中的CEO作为领头羊，为公司中的每个人都敬了酒，也包括我（一个实习生），说实话我很佩服，她没有高高在上咄咄逼人的傲气，没有那种说教性的服从测试，而是相互尊敬，合作共赢，温文尔雅又高端大气。公司的CTO也曾说过，我们是创业型团队，我希望大家都是奋斗者。其实在我看来，公司里的小伙伴都是奋斗者，每个人都有自己的思想，但是都为了共同的产品和目标而贡献者力量。这里祝前司越来越好。</p>
<h2 id="表达与传递"><a href="#表达与传递" class="headerlink" title="表达与传递"></a>表达与传递</h2><p><img src="https://s2.loli.net/2025/01/28/BvG7SL8Wx5deFsI.jpg" alt="在人大睁眼看世界"><br>有个著名的词语叫 <strong>keep thinking</strong>，说是要保持思考，不断思索，我想在这话后加上一句“学会表达”，也即 <strong>keep thinking and learn to express</strong> ，学过小学音乐的人都知道，音乐最重要的是表达，李健曾说过：“在最冷的时候，我会写一些抗拒寒冷的歌曲，我写过一首歌叫《温暖》。多年以后很多人问我为什么写这首歌，原因非常简单，因为我住的地方太冷了，温暖是我当时的渴求。”，学过小学摄影的也知道，摄影主要是记录与表达，优质vlog博主井越曾说过：“一张全黑的照片，但只有你知道，这是你的爱人当时在给你表白的时候那天晚上的天空，那么这张照片就是好的照片。”  </p>
<p><img src="https://s2.loli.net/2025/01/28/Lv7ykP8tlMJfEwG.jpg" alt="颐和园的冬天"><br>……喜悦了， 忧伤了，郁闷了，释怀了等等……只要能传达出所表达的，有意义的，那就是一个好的作品，表达不出来，那只能说欠缺火候。其实生活亦是如此，我自己是想法挺多的一个人，经常会想一些有的没的，在别人看来是思维跳跃或者是无厘头。有想法，也需要表达，就像一个输入输出的过程一样，每个人所表达的方式不一样，没有所谓标准的公式，正如我现在所写的文章一样也是表达，或许文笔欠缺，或许辞藻白涩，但是就是我个人的梳理与总结，我想我自己也已经表达出了我的东西，这对我来说，就是有意义的。</p>
<h2 id="探索与追寻"><a href="#探索与追寻" class="headerlink" title="探索与追寻"></a>探索与追寻</h2><p>2024年趁着假期与闲暇时光，去了一些地方，山海打樵的秦皇岛，集火山草原沙漠与一身的内蒙，百去不厌的天津东堤，以及满怀人文气息的淮南等，因为在北京的缘故，基本都是去附近的城市，其实想去的地方还很多，比如火星?()。人是奇怪的动物，总是喜欢新鲜的东西，总是喜欢得不到的东西。虽然是这样，我还是会去做自己喜欢的事情，就比如我喜欢音乐，我每天会不自觉的花时间去听歌，去学一些音乐相关的知识，参加合唱歌会与音乐节演出。我喜欢摄影，我看到喜欢的东西我就拍摄，同时也会学习一些影视的工具。人就活那么些日子，谁还不是为了提升幸福感而活着，而这里的幸福我想是由自己定义，而不是别人。  </p>
<p><img src="https://s2.loli.net/2025/01/28/eB3aCITwtqXrOKz.jpg" alt="拍一张桌面壁纸"><br><img src="https://s2.loli.net/2025/01/28/apRylxKtIenY4jD.jpg" alt="东堤火焰"><br>有时候我们茫茫碌碌，小时候用功读书，长大了努力工作，一年到看不到头，一年也看到了头。有的人每天匆匆忙忙就是一辈子，有的人活在他人的眼光丧失了自我，有的人为了所谓的荣华与富贵卑躬屈膝不敢抬头，有的人连自己想要的是什么也没弄清楚。或许，他们活的很精彩，但我个人的追求却不是这些。我的老友李导曾说过：“2025，找到自己内心的宁静”，诶我觉得说得很好，我也期望能<strong>找到自己内心的宁静，去做自己真正想做的事情。</strong></p>
<h2 id="展望与期待"><a href="#展望与期待" class="headerlink" title="展望与期待"></a>展望与期待</h2><p>好吧，扯了那么多，还是来展望一下2025吧，在此之前先回顾一下去年的：<br><img src="https://s2.loli.net/2025/01/28/GRKmQAIaYopDkxW.png" alt="24年flag"><br>2024年收获了一份满意的实习，去了不少地方探索游玩，也结交认识了很多志同道合的朋友。好像都实现了，也没有那么难嘛，看来今年得上点难度</p>
<blockquote>
<p>收获满意的大厂offer，秋招顺利<br>有一份自己的副业<br>去更多更远的地方探索游玩<br>结识更多的伙伴朋友</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2024年没有轰轰烈烈，没有刻骨铭心，但是确是精彩的一年，借用周董的一句话：“<strong>有人加入，有人退出，但是你曾经加入，我也很感谢你。</strong>” 新年快乐，2025，我们一起加油呀！<br><img src="https://s2.loli.net/2025/01/28/RApVHlXhW3nsJLF.png" alt="新年快乐！"></p>
<h2 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h2><p><img src="https://s2.loli.net/2025/01/28/ufBxpehn5WXjQcT.jpg" alt="干杯！"><br><img src="https://s2.loli.net/2025/01/28/spStDucNaZ2w9rI.jpg" alt="海边捞"><br><img src="https://s2.loli.net/2025/01/28/H6wc9MogJIBe7Uu.jpg" alt="沾衣欲湿杏花雨"><br><img src="https://s2.loli.net/2025/01/28/KDPRMCfQjISAh6z.jpg" alt="讲好中国故事"><br><img src="https://s2.loli.net/2025/01/28/qO4DHvRU6jImwoX.jpg" alt="淮南行"><br><img src="https://s2.loli.net/2025/01/28/fZqnENOQyctjFou.jpg" alt="响沙湾"><br><img src="https://s2.loli.net/2025/01/28/GNj4qPTSuxnfMWZ.jpg" alt="20岁"><br><img src="https://s2.loli.net/2025/01/28/JCOgiPtsp4oB9rx.png" alt="你想活出怎样的人生？"><br><img src="https://s2.loli.net/2025/01/28/7FkMurXNpDPGqbd.jpg" alt="世界人民大团结万岁！"><br><img src="https://s2.loli.net/2025/01/28/DTWo16ghsiVmPIX.jpg" alt="爱是奔赴着不朽的"><br><strong>无限进步！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>因为山就在那里</title>
    <url>/2023/11/18/%E5%9B%A0%E4%B8%BA%E5%B1%B1%E5%B0%B1%E5%9C%A8%E9%82%A3%E9%87%8C/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/11/18/zBw96x5uDZNenMX.jpg"> </p>
<p>第一次爬北京的山，看到了不一样的风景，也收获到了意外的体验。虽说是3A级景区，但这次给我的体验远不止3A，恰巧赶上了日落，路上遇到了小猫，2000多米的爬山体验，给我的感觉是，棒极了。  </p>
<span id="more"></span> 
<hr>
<h3 id="千里之行，始于足下"><a href="#千里之行，始于足下" class="headerlink" title="千里之行，始于足下"></a>千里之行，始于足下</h3><p>也许是最近在学校待久了吧，课堂上一些公式化的学习生活有时让人觉得些许枯燥，刚好最近特别想去爬山，想去那就去呗！于是乎，我咨询了一下经常在北京各大山区骑行游览的同学，他随手推荐了离学校不远的蟒山。我上地图搜了一下，在网上简略地看了一下攻略，就决定出发了。没想到的是，另外有两位同学也打算出去走走，我说，那就一起呗，反正也不远。就这样，我收获了两个小伙伴。出发前，我东西收拾得差不多了，但我依然还在想是不要再准备些什么？思索了一下，我觉得不用再考虑太多了，千里之行，始于足下，想做就直接去做先，直接行动起来！  </p>
<hr>
<h3 id="山路崎岖，拥抱自然"><a href="#山路崎岖，拥抱自然" class="headerlink" title="山路崎岖，拥抱自然"></a>山路崎岖，拥抱自然</h3><p>在到达正式爬山之前，其实还是经历了许多的小插曲。当天我们三人是坐地铁到达关东站，然后骑着共享单车去到蟒山国家森林公园的入口。但是骑到一半突然觉出似乎山区附近没有停车点，于是本来已经快到山脚下的我们决定原路返回一段距离去最近的停车点。好在最近停车点不远，也没有迂回多少。之后我们开始等公交，可等了一会儿也没见车来，我索性提出直接打车，然后刚打车就有师傅接单了，发现路费也不贵，其实也就10来分钟的路程，不过上山有点坡度，所以骑车可能会久些。就这样我们来到了入口。检完票进去后就面临路线的选择，我想着先从山脚走起吧，就先往文化广场的方向走去。蟒山森林公园其实好多小景点都别有一番风味。<br><img src="https://s2.loli.net/2023/11/19/7gbknJIiecvRoDm.jpg">  </p>
<p>一走进森林公园，给我的感觉就是：“清爽”！在这里，你可以深吸一口气，不用担心烟尘啥的，这里的空气让人很舒服。旁边这些小树林也别有也一番风味，阳关透过枝叶映射在地面上，一条一条的，很有感觉。最重要的是，这里人流很少，是真正的清净！路上有很多的休息椅子，累了也能随时坐会儿，开始给我一种真正世外桃源的感觉。  </p>
<p><img src="https://s2.loli.net/2023/11/19/d9vpNHwF32ZWy1Y.jpg">  </p>
<p><img src="https://s2.loli.net/2023/11/19/G67RqEiShY8VUAm.jpg"><br>在体验一番过后，突然来到了观蟒台，说实话， 我好像没咋观出哪里是蟒，可能是还在蟒山脚的缘故，看得不是很开阔，但是风景还是不错的。之后我们开始往山上的方向走去，途中经过了蟒山叠翠、碑林、然后就到了文化广场，广场上面有个水池（忘记叫什么了）。这些景点我个人感觉不是很惊艳，但也算是有该有的吧，水池是个环形的，能看到山的倒影，也算还行吧。<br><img src="https://s2.loli.net/2023/11/19/c2ZYXOgaeqw3jyd.jpg">  </p>
<hr>
<h3 id="山不向我，我向山去"><a href="#山不向我，我向山去" class="headerlink" title="山不向我，我向山去"></a>山不向我，我向山去</h3><p>经过这些小景点的兜兜转转后，我们才算最终踏上了通向山顶的道路，也能明显地感到坡道有些坡度了。我们往五观台的方向爬去，五观台，听说是观五样东西，一个是京城什么的，一个是水库什么的，其他几个也记不太清了，反正就是看五样不同的景观。开始上去的时候有路牌提示，说据顶点还有2000来米，大约需要2个小时，当时看了还是有些吃惊的，竟然这么高吗？没事，反正我也没咋去过，就直接上呗。于是，一个接着一个的台阶就这样在我的脚下流过。  </p>
<p><img src="https://s2.loli.net/2023/11/19/7ofi1CFbth8yJ43.jpg">  </p>
<p>开始的山景似乎没特别惊艳的，因为也许还没到半山腰，景色不是很丰富，但也有不同的植被，也能看到一些小山的景色。一开始觉得没什么难爬的，可能会稍微耗点体力，但是走了一小阵后发现确实有些小累，于是我们开始稍微歇会儿。歇会儿过后又继续前进，路上也碰到了一些来爬山的人，不过也不多。我们一路走着，路上也有不一样的景色，当我们走着走着时，发现太阳似乎快要落山了，有一个角度望去特别的好看，突然的这样的景色也让我给惊艳到了。<br><img src="https://s2.loli.net/2023/11/19/kxB3QMi9Yjeqlzy.jpg"><br><img src="https://s2.loli.net/2023/11/19/JAahteflu3oUZjs.jpg"><br>不知为什么，从此刻起，突然觉得现在山上的景色好好看，让原本些许累的我们也放松了一下，脚上的累也消了不少。就这样，我们一边欣赏着夕阳，一边继续前行。路上还遇上了一只“学长”，“学长”挺胖挺可爱的。  </p>
<p><img src="https://s2.loli.net/2023/11/19/ZdK5fStEBvFk3zA.jpg">  </p>
<p>太阳马上就落山了，我们也目睹了这场绝美的日落  </p>
<p><img src="https://s2.loli.net/2023/11/19/brQ3s8l7JhyBo6w.jpg">  </p>
<p><img src="https://s2.loli.net/2023/11/19/bvoPXS4c1ZVxgFI.jpg">  </p>
<p><img src="https://s2.loli.net/2023/11/19/WxqYHV6LehuylZv.jpg">  </p>
<p><img src="https://s2.loli.net/2023/11/19/b8Z1t5U9cB2W6VN.jpg">  </p>
<p><img src="https://s2.loli.net/2023/11/19/be5wACm83Zvh4qK.jpg">  </p>
<p>其实太阳落得很快，估计就几秒的时间，可能美好的东西总是很短暂吧！这也让我想起了“夕阳无限好，只是近黄昏”，但是呢，我又觉着“莫道桑榆晚，为霞尚满天”，虽然从岁数来说，放在我们身上不太合适吧，但是我觉得从做事角度，其实还是要怀抱希望，做自己热爱的，现在出发去做，不会太迟。我没有用手机录下它日落那一瞬，而更多是用眼睛去感受了。  </p>
<h3 id="半山腰有些拥挤，到山顶看看"><a href="#半山腰有些拥挤，到山顶看看" class="headerlink" title="半山腰有些拥挤，到山顶看看"></a>半山腰有些拥挤，到山顶看看</h3><p><img src="https://s2.loli.net/2023/11/19/GtlVwKEQ9zopMib.jpg"><br>太阳已经落山了，但距离山顶还有一段距离，考虑到待会还要下山，心里有些犹豫。但是呢，山顶就在眼前了，总得去看看吧，反正现在也不算太晚，路上还有些人，于是我们就一鼓作气，冲向了山顶。  </p>
<p><img src="https://s2.loli.net/2023/11/19/lshMWK2NVEzpmni.jpg"><br>可能是冬天+北方吧，天黑得比较快，这会儿月亮也出来了，人们也点起了灯火，从山顶上望去，夜景还是挺好看的。  </p>
<p><img src="https://s2.loli.net/2023/11/19/Vxz7RJAG6KUqHto.jpg"><br>天黑了，也不敢待太久，稍微看看后就下山去了，幸好我们有三个人，不然我还真不敢上来。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本次爬山给我的收获还是挺大的，在山里面，花花草草，虫虫鸟鸟，一山一木，一水一露，让人感到十分清净。我觉得的是，得顺其自然，做你想做的事，有想法就直接行动；做你热爱的事情，喜欢才会有动力；做能让你感到开心和快乐的事情，不必背着自己的内心，做一些不开心不快乐的事。很喜欢的的一句话：“为什么要登山？因为山就在那里”。是的，山就在那里，它们不会走动，你去它那，它就会给你反馈，给你舒心。也许它们不会说话，但是它又无时无刻不在与你互动呢？偶遇的绝美日落，半山腰出现的“可爱学长”，问鼎山峰后的夜景，这才是真正的交流，所以，喜欢就去做呗，不用太在意结果，路途中的美景本身就是一种收获，在过程中，也许就能找到答案了。</p>
]]></content>
      <tags>
        <tag>风景</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将两个很大的数进行相加？</title>
    <url>/2023/10/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AE%97%E6%B3%95%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="经典大数相加算法、高精度加法"><a href="#经典大数相加算法、高精度加法" class="headerlink" title="经典大数相加算法、高精度加法"></a>经典大数相加算法、高精度加法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>先上一道题</strong>：<a href="https://leetcode.cn/problems/add-strings/"><strong>LC415.字符串相加</strong></a>     </p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<hr>
<p>对于这道题，可能很多朋友会想到将两个字符转为数字，然后将其进行相加，最后将结果再转为字符串。这种方式可行，但是如果数字非常大呢？大到连long long 都不够加呢?那我们就得请出我们的主角：<strong>高精度加法</strong>。  </p>
<span id="more"></span>
<h2 id="高精度加法是什么？"><a href="#高精度加法是什么？" class="headerlink" title="高精度加法是什么？"></a>高精度加法是什么？</h2><p>百科上的定义：高精度加法是信息学的一种重要算法。这种算法使用多个存储单位进行计算，因此它的计算范围超过一般使用一个存储单位的算法。所谓高精度加法，其实就是<strong>竖式加法</strong>，竖式加法我们在小学2年半的时候都学过，例如我要实现114 + 514，那就是：<br><img src="https://s2.loli.net/2023/10/18/2DF5GTCgQUMhOHW.png" alt="竖式加法.jpg">   </p>
<p>如上图所示，我们从个位开始相加，4 + 4 &#x3D; 8，然后到十位，1 + 1 &#x3D; 2，接着到百位，1 + 5 &#x3D; 6，所得结果就是628。所示例子没有进位，如果有进位的话，需要加上进位值。如9 + 3，需要进1，本位是2。</p>
<h2 id="为什么需要高精度加法？"><a href="#为什么需要高精度加法？" class="headerlink" title="为什么需要高精度加法？"></a>为什么需要高精度加法？</h2><p>高精度加法原来就是所谓的竖式相加，这不是小学生都会吗？其实，高精度加法在计算机算法中有着重要的应用。我们知道,在C&#x2F;C++语言中，通常来说（32位机器）,<strong>int、long类型占32位，long long类型占64位，而最大的类型unsigned long long能表示的最大数也就才(1e19+8e18)</strong> ，如果要几百位的数来进行相加，那就不行了，所以，我们就可以使用高精度来计算，高精度一般也会用来处理大数相加的问题。</p>
<h2 id="高精度加法实现（C-）"><a href="#高精度加法实现（C-）" class="headerlink" title="高精度加法实现（C++）"></a>高精度加法实现（C++）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们将两个大数采用字符串的形式输入，然后模拟竖式加法的过程，<strong>用两个指针，先从个位开始相加（即字符串的最后一位），我们定义一个变量add来存进位值（如果没有进位则为0），然后逐步往高位移动，继续相加。考虑到两个数位数会有不一样的情况，有一个先加完，一个后加完，那我们采取将先加完的数的剩余位默认补0的方式即可</strong>，具体代码实现如下。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从个位开始相加，初始化进位add为0</span></span><br><span class="line">        <span class="type">int</span> i = num1.<span class="built_in">length</span>() - <span class="number">1</span>, j = num2.<span class="built_in">length</span>() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;<span class="comment">//定义一个空字符串来拼接答案</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当其中一个数没加完或者进位大于0时执行循环</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//当前位数没有加完则为本身，加完的话则默认为补的0</span></span><br><span class="line">            <span class="type">int</span> x = i &gt;= <span class="number">0</span> ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = j &gt;= <span class="number">0</span> ? num2[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> result = x + y + add;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前位的值加入ans</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span> + result % <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新进位值</span></span><br><span class="line">            add = result / <span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//由于每一位插入时是尾插导致低位在前，翻转一下即可</span></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(max(len1, len2))，其中len1和len2分别为两字符串的长度。  </li>
<li>空间复杂度：O(1)，我们只需要常数空间来存储若干变量。</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/add-binary/"><strong>LC67.二进制求和</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/"><strong>LC2.两数相加</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/"><strong>LC445.两数相加II</strong></a>    </p>
<hr>
<p>这里我们研究一下两数相加这题，题目如下：  </p>
<p><strong>LC2.两数相加</strong><br>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><img src="https://s2.loli.net/2023/10/18/OfD6LoA2caST81m.png" alt="add-two.png"></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果仔细看完高精度加法的内容的话，会发现，这也不还是相当于模拟加法的过程吗?只是存储形式从字符串变为了链表而已。我们先<strong>把两链表头看成最低位即个位，开始进行相加，同样我们也用一个变量add来存储进位值，接着进行下一个节点的相加，一直到链表为空,同样也是会有一个链表先走完的情况，那我们将先走完的剩下的空位补0即可</strong>。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建头指针和尾指针</span></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义变量表示进位值，初始化为0</span></span><br><span class="line">        <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//当其中一个链表不为空时或者进位值不为0时进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || add &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = l1 ? l1 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y = l2 ? l2 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = x + y + add;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个节点来存储相加后当前位的值</span></span><br><span class="line">            ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">                head = tail = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail -&gt; next = tmp;</span><br><span class="line">                tail = tail -&gt; next;<span class="comment">//更新tail</span></span><br><span class="line">            &#125;</span><br><span class="line">            add = sum / <span class="number">10</span>;<span class="comment">//更新进位值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//迭代往下走</span></span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><p>我们在上面入门学习了高精度加法，即模拟竖式计算，也通过字符串相加，两数相加等题目对其有了更深的理解。那其实，有<strong>高精度加法，当然也有高精度减法、高精度乘法、高精度除法</strong>，其实本质上都是在模拟我们竖式计算的过程。而这些高精度计算的方法，为我们计算大数提供了可行方式，今后我们也会逐渐地深入学习和了解。</p>
<blockquote>
<p>以上就是字符串相加、经典大数相加算法(高精度加法)入门的全部内容了，如果文章有什问题或者错误，或者有什么建议和想法，欢迎随时和我交流。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>小乐趣与大理想 ——安徽邂逅</title>
    <url>/2024/10/07/%E5%B0%8F%E4%B9%90%E8%B6%A3%E4%B8%8E%E5%A4%A7%E7%90%86%E6%83%B3%E2%80%94%E2%80%94%E5%AE%89%E5%BE%BD%E9%82%82%E9%80%85/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/10/12/3tjZPmNBkDwVX9J.jpg" alt="淮河"><br>调侃棉袄的大妈，喜欢历史的出租车司机，颇受议论的淮南天目湖，文艺感十足的造纸厂和发电厂，蜿蜒的淮河，臭鳜鱼，冰酒酿，八公山豆腐，淮南牛肉汤，皖北地锅鸡……这次旅行虽然所到之地不多，但我反倒能更好的去了解这片地区，交流的过程也能更好的去认识自己。</p>
<span id="more"></span>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年是我上大学以来的第三个国庆节，和以往不同的是，这次的国庆，我没有选择去热门的旅游景点，也没有选择在假期进行所谓的“弯道超车”，而是选择了一个折中的地方——安徽，一个原因是我确实没咋体验过中部地区的文化，另一个原因则是我的同行伙伴在厦门，而我在北京，这样的安排对俩人都合适些。</p>
<h1 id="合肥"><a href="#合肥" class="headerlink" title="合肥"></a>合肥</h1><p>刚下火车，出来的第一眼感觉像是南宁，我在街道上闲逛，闻到牛肉粉的香味后，小嗦一碗便结束了初来的上午，下午去南站接了朋友，说实话当天晚霞还挺美。  </p>
<p><img src="https://s2.loli.net/2024/10/12/ecltUFBju2Rza14.jpg" alt="南站夕阳">  </p>
<p>我们拖着行李就前往酒店，路上遇上了许多有趣的事情，令我印象深刻的一件是有位大妈从我们旁边经过时调侃了一句：“现在就穿棉袄了，冬天还得了？”说来我从北京出发，当时下雨大降温，一度感觉是不是要入冬了，索性穿了个棉袄，没想到却成为了开门之乐，我们也怡笑不已。10月初合肥的温度适中偏下，我感受到的是秋天的凉。</p>
<h2 id="city-walk"><a href="#city-walk" class="headerlink" title="city walk"></a>city walk</h2><p>我喜欢来一座城时先city walk一番，刚好也熟悉一下当地的特色。合肥的街道感觉有很多地方的影子，有北京的萧肃，有杭州的悠然，有天津的随性，也有像上海一样的底蕴。令我关注的是这边的共享单车很多，甚至共享电单车都有很多，这点很南宁。也许是在北方待了许久吧，要知道北方很少会有共享电单车的。合肥似乎没有5A级别的景点（或者是我没发现？），当然这也无所谓，很多时候去一条小街，走一个小巷往往更贴风俗。合肥公园挺多的，包公园、逍遥津这俩比较出名些，包公园像一个庭院园林，逍遥津则更大些。  </p>
<p><img src="https://s2.loli.net/2024/10/12/A9ibTHdgUJvFc4f.jpg" alt="包公园"><br><img src="https://s2.loli.net/2024/10/12/4hpFewZR2xuHJdO.jpg" alt="逍遥津听曲">  </p>
<p>晚上去觅食，来到安徽当然要品尝徽菜了，不过徽菜作为八大菜系之一，我竟然不知道有什么，算是孤陋寡闻了，一番搜寻，本打算去吃皖北地锅鸡，却误打误撞点了个黄山臭鳜鱼以及两份小菜。  </p>
<p><img src="https://s2.loli.net/2024/10/12/Ky7F9sElYzx5B2I.jpg" alt="徽菜">  </p>
<p>臭鳜鱼闻着确有一股怪味，但是吃起来一绝，肉感脆嫩，吃起来香而不腻，味而不咸，这里我个人很推荐。</p>
<h2 id="遇见博物"><a href="#遇见博物" class="headerlink" title="遇见博物"></a>遇见博物</h2><p>在市中心及附近吃喝玩逛了两天，第三天打算去安徽博物馆，这个行程是我朋友安排的，所实话一开始我没打算去博物馆，不过此行却让我眼前一亮。刚好有个希腊古迹展览在里边开，朋友建议一起去看说实话我一开始还不太想去，我觉得这个希腊古迹和安徽没啥关系吧，我在北京也能看啊。然而这种想法在我进去展览后直接消失得无影无踪，我立马喜欢上了这些展览。从希腊神话到雅典城帮，从艺术哲学到奥林匹克……，每一样东西都很有趣。  </p>
<p><img src="https://s2.loli.net/2024/10/12/6EtCPSeNbfB5XZQ.jpg" alt="爱是奔赴着永垂不朽的"><br><img src="https://s2.loli.net/2024/10/12/eZtVKnmCSE3iMUW.jpg" alt="生育女神与丘比特"><br><img src="https://s2.loli.net/2024/10/12/Bg6c5zRNvyn2F8P.jpg" alt="嘉奖令"></p>
<p>我更偏爱神话一些，也许是神话都富含神秘与浪漫主义色彩吧，但其又能反应现实的世界，我觉得很妙。<br>当然，还是要“认识我自己”。  </p>
<p><img src="https://s2.loli.net/2024/10/12/2lEjrfcusvzoNBS.jpg" alt="结语">  </p>
<p>看完希腊展后，我们继续观赏博物馆，说实话，很多东西在别的博物馆也有，可能兴趣不是很大，兴趣比较大的是一些书画展，文房四宝这些，我们熟悉的宣纸就来源于此地。  </p>
<p><img src="https://s2.loli.net/2024/10/12/3qToYkD5tLr7PyO.jpg" alt="生宣"></p>
<h2 id="中科大"><a href="#中科大" class="headerlink" title="中科大"></a>中科大</h2><p>到安徽当然要探访一下中国科研实力最强的学校之一的“中国科学技术大学”。刚走进这所学校，给我的感觉是内敛、踏实，没有噪动，没有喧嚣。  </p>
<p><img src="https://s2.loli.net/2024/10/12/XgVzPfIauJ69pTM.jpg" alt="中科大傍晚">  </p>
<p>甚至走在小路上都有一种让人感到“异常”的静谧，当然也许是国庆人们都不在校园，这个我也不太清楚。<br>中科大的室内给人眼前一亮，丰富度比室外好很多，有种实力不外露的感觉，当然也就是内敛。  </p>
<p><img src="https://s2.loli.net/2024/10/12/6PqBSXbGYCpJzF8.jpg" alt="中科大室内"></p>
<hr>
<h1 id="淮南"><a href="#淮南" class="headerlink" title="淮南"></a>淮南</h1><p>因淮南离合肥不远，就顺路去游览了一下，淮南的物价很便宜，虽然他是一个市级地，但是给我的感觉更像是一个县城。这里的烟火气足，人文气息很浓，历史底蕴也厚重。</p>
<h2 id="天目湖"><a href="#天目湖" class="headerlink" title="天目湖"></a>天目湖</h2><p>淮南附近也没有特别著名的景点。有个4A级景区——天目湖，素有中国“马尔代夫”之称。去湖的路上遇到了个喜欢历史的司机，他给我们介绍了当地的一些人文历史。  </p>
<p><img src="https://s2.loli.net/2024/10/12/NhZr9BPUXCJoR5s.jpg" alt="喜欢历史的司机">  </p>
<p>天目湖据说就是一个大矿坑，里面的水是人工填充的。淮南的寿县古城富有历史底蕴，很多战役发生在这边，如“以少胜多”的淝水之战，还有很多成语，草木皆兵，风声鹤唳，当然还有我印象比较深的是淮南是豆腐的发源地，据说淮南王刘安当时为了长生不老开始炼仙丹，最后仙丹没练成，发明了豆腐，“一人得道，鸡犬升天”就是来自于此。当然历史典故还有很多，这里就不做展开。<br>天目湖其实也不是很大，但是对于是一个矿坑来说，体量就有点惊人了，我们下午4点才去的，当时是阴天，没什么太阳，不过别说风景确实独特，  </p>
<p><img src="https://s2.loli.net/2024/10/12/A9rtfuisa4VR6gd.jpg" alt="天目湖"><br>我和朋友实践了一下摄影艺术，虽然实践成果一坨……，然后就回市中心去了。</p>
<h2 id="淮南牛肉汤"><a href="#淮南牛肉汤" class="headerlink" title="淮南牛肉汤"></a>淮南牛肉汤</h2><p>也许没听说过淮南，但肯定听说过淮南牛肉汤，我们去前锋小吃街的一家店来了份牛肉汤，别说，确实好喝！  </p>
<p><img src="https://s2.loli.net/2024/10/12/guVQkRij93WT1Pe.jpg" alt="淮南牛肉汤">  </p>
<p>比较传统的淮南牛肉汤是带有些辣味的，会放不少辅料下去，据说是补身子。之后我们也顺带尝了下铁板豆腐，  </p>
<p><img src="https://s2.loli.net/2024/10/12/hl8UaitoKLpu46Q.jpg" alt="铁板豆腐">  </p>
<p>确实当地的豆腐吃起来更有韵味，以及安徽这边发源的冰酒酿，各有特色，确实很有风味。当然从小吃街中可以感受到当地烟火气，忙碌与“繁华”。  </p>
<p><img src="https://s2.loli.net/2024/10/12/DZ8zxntNj7qgLUE.jpg" alt="市井烟火"><br><img src="https://s2.loli.net/2024/10/12/2HO4SceQb6tpUMj.jpg" alt="水果摊"></p>
<h2 id="造纸与发电"><a href="#造纸与发电" class="headerlink" title="造纸与发电"></a>造纸与发电</h2><p>淮南虽然是个四线城市，但是曾经的实力和地位却异常重要，因为这边曾经有挖煤许可，有造纸厂与发电厂，听前边的师傅说，挖煤必须要有挖煤许可才能够开采，而全国几乎没有多少个城市是允许的，而造纸厂与发电厂当时在全国也是比较稀缺。造纸厂刚好我们去的时候没有开放，有点小可惜。  </p>
<p><img src="https://s2.loli.net/2024/10/12/QmFVoDr2yx6Cngs.jpg" alt="造纸厂门前">  </p>
<p>现如今这些产业在淮南带动不了多大的作用了，淮南的转型升级目前仍面临着挑战。于我个人而言，淮南是个小众但值得一去地方。  </p>
<p><img src="https://s2.loli.net/2024/10/12/3oxiglUGMzvjBW2.jpg" alt="工厂">  </p>
<p>我们去淮上渡口转了一转，看了看淮河，河岸两边想渡河需要走船运，包括货物，汽车，行人等。  </p>
<p><img src="https://s2.loli.net/2024/10/12/WRfTpmtONrUu9cK.jpg" alt="渡口">  </p>
<hr>
<h1 id="乐趣与理想"><a href="#乐趣与理想" class="headerlink" title="乐趣与理想"></a>乐趣与理想</h1><p>一转眼国庆假期就过去了，四五天的时间就“浪费”在了这两座城上，也许我们来的地方也只不过是别人待腻的地方罢了，这有什么意义吗？我想还是有的，因为有些东西见过就是见过，没见过就是没见过，旅途也是一种自我对话的方式，在时空位移的同时会碰上很多概率事件，而在期中的反应，经历也是一种探索了解世界的方式，读万卷书，也要行万里路嘛。在酒店的时间里我们聊音乐，聊摄影，聊人生理想，临走的那一晚看了个李健在清华的演讲，李健说到：“拥有并学会经营自己的小乐趣常常胜过远大理想。”  </p>
<p><img src="https://s2.loli.net/2024/10/12/jIuWQBhpJryxKvN.jpg" alt="李健"><br>我想是的，那些看似没用的“乐趣”，常常会给我们很大的帮助，也许每个人都会去追求一些乐趣，但追寻乐趣又何尝不是一种追寻理想呢？或者说追寻理想为什么不能是乐趣的呢？我想只有去追寻，去探索，答案才在其中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>“青春其实不只是指年轻，而更是指拥有一种好的状态。”我想趁年轻的时候更多地探索、体验这个世界，同样，我也更希望自己能够保持一颗充满好奇、敢于实践的心，去见识更多不一样的“风景”。</p>
<p><img src="https://s2.loli.net/2024/10/12/2biZSmn3B9Q4zgI.jpg"><br><img src="https://s2.loli.net/2024/10/12/U8W3tu2Q6ZonA5s.jpg"><br><img src="https://s2.loli.net/2024/10/12/xXgBKsrAiRd3Oa2.jpg"><br><img src="https://s2.loli.net/2024/10/12/jQm4oFz1TGrqYlA.jpg"><br><img src="https://s2.loli.net/2024/10/12/4YG3OVWSNkcEslT.jpg"><br><img src="https://s2.loli.net/2024/10/12/lry6Znq9c8DtXk7.jpg" alt="kk"></p>
]]></content>
      <tags>
        <tag>风景</tag>
      </tags>
  </entry>
  <entry>
    <title>我与旧事归于尽，来年依旧迎花开 ——启2024</title>
    <url>/2024/02/09/%E6%88%91%E4%B8%8E%E6%97%A7%E4%BA%8B%E5%BD%92%E4%BA%8E%E5%B0%BD%EF%BC%8C%E6%9D%A5%E5%B9%B4%E4%BE%9D%E6%97%A7%E8%BF%8E%E8%8A%B1%E5%BC%80-%E2%80%94%E2%80%94%E5%90%AF2024/</url>
    <content><![CDATA[<p>“人只有用心看才能看得清楚，重要的东西用眼睛是看不见的。”  </p>
<p><img src="https://s2.loli.net/2024/02/09/SsAUhj7XYW5vPTy.jpg" alt="颐和园.jpg"></p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>光阴似箭，日月如梭。这一年于我而言，过得十分飞快，仿佛还在刚考上大学的那段日子里，还是个刚踏入大学校园的懵懂新生。但是转眼看着当下，我也成为了别人眼中所谓的学长。这一年，认识了很多优秀的人，也结识了许多朋友，也经历了各种各样的事情。和去年一样，吃了很多亏，也做过很多傻事，同样，我也收获许多。前几天看了一期《开讲啦》，嘉宾是李健，他说：“大学对我来说才是真正的成长”。我想于我而言，也是的。</p>
<hr>
<h2 id="万卷书-amp-万里路"><a href="#万卷书-amp-万里路" class="headerlink" title="万卷书&amp;万里路"></a>万卷书&amp;万里路</h2><p>自古就有读万卷书和行万里路的说法，关于到底是选读万卷书还是行万里路的话题也至今难辨。在此我把其归为学习与实践，我觉得于我们个人而言，两者应皆需兼备。这一年学习了不少东西，技术的，非技术的，专业的，课外的。读了一些书，专业的例如《C++ Prime》《Linux鸟叔私房菜》，课外的诸如《小王子》《亲密关系》等。  </p>
<p><img src="https://s2.loli.net/2024/02/09/xFPC7s5kyqmcf8z.jpg" alt="教室学习.jpg"></p>
<p>很多书籍都是从图书馆借的，其实还是挺感谢学校。纸上得来终觉浅，绝知此事要躬行。实践是认识的过程，认识也源于实践。其实相比而言，我更喜欢实践，我喜欢亲自去参与其中的过程与体验。这一年，参与了很多活动，如WWDC之夜北京会场、字节跳动OpenDay、北大无人机挑战赛开幕式、国际大学生魔术表演，增长了见识，也开阔了眼界。参加了一些比赛，如：互联网+、ACM、创新杯等，锻炼了自我，也收获了成长。在学习与实践中，收获都是能感受到的。通过与ifLab导师和同学们交流学习，我对自己的学习与规划有了更多的了解。通过参加ACM校队的集训，我对“坐牢”有了深刻的理解，哈哈，开个玩笑，通过一道一道编程题的集训，我的编程算法思维有了一定的提升。在校团委宣传部的工作与学习，让我对整个新媒体运营的流程与机制有了自己的认知，同时我也学习具备了基本的设觉设计处理与视频剪辑能力。</p>
<p><img src="https://s2.loli.net/2024/02/09/x7zFXgd2i3GevNp.jpg" alt="字节跳动openDay.jpg"><br><img src="https://s2.loli.net/2024/02/09/TILQWrSn2dwmNob.jpg" alt="北京市大学生程序设计竞赛--腾讯北京总部.jpg"></p>
<p>与优秀的人为伍，能成长得更快，抱着学者的心态去与人相处交流，我认为这对自己有很大好处。</p>
<hr>
<h2 id="变局"><a href="#变局" class="headerlink" title="变局"></a>变局</h2><p><img src="https://s2.loli.net/2024/02/09/GAxy2DVv8nS6df1.jpg" alt="Apple WWDC之夜.jpg"><br>中国有本阐述天地世间万象变化的古老经典，叫《易经》。而这里易的一个意思就指的是改变、变化。世界在变，时代在变，个人也跟着在变。2023年出现了前所未有之变局，AI取代的会是马还是马车夫？戴上Vision pro后我们的世界是更清晰还是更模糊？幻兽究竟是帕鲁还是我们自己？自我的每一个抉择最后是庆幸还是后悔？或许每个人都有自己的答案，又或许没有人能够回答。我想，行动仍然是最有意义的答案。“变亦变，不变亦变。” 变的东西在变化着，看似不变的东西也在悄然变化着，世界正经历着未有之变局，而于我个人更是悄悄地被周围的一切潜移默化地影响着，不要害怕抉择，不要囿于行动。在抉择的刹那，本身就已经是向前；当行动的时候，答案就藏其中。</p>
<hr>
<h2 id="月亮"><a href="#月亮" class="headerlink" title="月亮"></a>月亮</h2><p>“醉后不知天在水， 满床清梦压星河。”很幸运，在2023年遇到了人生中的第一次恋爱，但最后还是没能一起走下去。从最初的心动、相知、相处、再到最后的分离，有欢笑也有泪水，有幸福也有遗憾。其实爱情并不是我们想象中的那么简单，其实到最后你发现是有很多责任在的。找到一个彼此欣赏且合适的人本身就不容易，更何况爱与责任了。<br><img src="https://s2.loli.net/2024/02/10/vAOcpQgIi2f6Voy.jpg" alt="玫瑰.jpg">借用李健《中学时代》中的歌词：  </p>
<blockquote>
<p>爱是什么<br>我不知道<br>我不懂永远<br>我不懂自己  </p>
</blockquote>
<p>爱是什么？我还不知道。谁能懂永远？谁又能懂自己？有人说恋爱是一门必修课，也有人说恋爱是一门选修课。其实无论选修还是必修，它都是一门课，而且，这门课的难度不简单。罗兰米勒在《亲密关系》中写道，“良好的亲密关系可以带来快乐和满足感，让人感到幸福和被爱，而建立良好的亲密关系是一个过程，需要信任、尊重、理解和包容，需要付出努力和时间来建立和维护。” 如果要问我亲密关系中最重要的是什么，我现在会说是“真诚”与“忠诚”。如今已过了几个月，失恋的时间里，我读了很多书，看了很多电影，现在回头来看，还挺感谢这次遇见，感谢这段经历，教会我很多，也让我成长许多。《lalaland》中有有一句台词”You’re holdin’ onto the past, but jazz is about the future.” 是的，爵士是放眼未来，我想我也会以最好的姿态，去迎接下一次的遇见，拥抱真正属于自己的月亮。</p>
<hr>
<h2 id="人间万象"><a href="#人间万象" class="headerlink" title="人间万象"></a>人间万象</h2><p>‘情’字不好解，通常难以落笔，但是那也只是生命中的一部分。爱人先爱己，擒贼先擒王（不好意思这句串场了）。23年的生活，没了疫情的喧嚣，也不用再上形同虚设的网课，我也得以有更多机会体验北京这座有其独特魅力的城市，也得以接触更真实的人们和世界。我感受了故宫的辉煌与宏伟，体验了皇家园林颐和园的气派，走过什刹海、南锣鼓巷等文化街道，也去了清华北大等顶尖学府拜访学习。用陶潜的一句话说就是“久在樊笼里，复得返自然。” 11月末，我去了国家森林公园蟒山，在那也看到了不一样的北京。<br><img src="https://s2.loli.net/2024/02/09/IKPR1lNAUwM8Faz.jpg" alt="故宫.jpg"><br><img src="https://s2.loli.net/2024/02/09/mecWZaV2KiwkYPD.jpg" alt="蟒山.jpg"><br>生活不只眼前的苟且，还有诗和远方。23年除了在北京转悠，我还去了好几个城市，诗情画意的杭州，魔都上海，古老而又现代的天津。好像挺有意思的，每次去旅行总能认识新的朋友。在西湖旁遇到了一位也来西湖游玩漂亮的小姐姐，我们和她一边交流着，一边感受西湖的美景。在上海我认识了老友的表哥，彼此洽谈，收获许多。天津之旅还认识了同乡的同学，我们也因此熟悉成为朋友。<br><img src="https://s2.loli.net/2024/02/09/dhEkNDviL9WC37t.jpg" alt="杭州行.jpg"><br>人总是茫茫碌碌，一年到头，奔波劳累，也常陷入迷茫。《小王子》中曾说，“人只有用心看才能看得清楚，重要的东西用眼睛是看不见的。” 我想是的，我们得听从自己的内心。学习工作之余，我依然会拿起吉他，唱着些自己喜欢的歌，“北方的村庄，住着一个，南方的姑娘~ 她总是喜欢穿着带花的裙子，站在路旁~” 我觉得是，在这个喧闹快节奏的时代，不要忘了自己的喜欢与坚守。</p>
<hr>
<h2 id="who-am-i"><a href="#who-am-i" class="headerlink" title="who am i?"></a>who am i?</h2><p><img src="https://s2.loli.net/2024/02/10/gVDaopf5eTxO1cl.jpg" alt="晚霞.jpg"><br>Windows用户用win + R打开运行窗口，输入cmd打开命令行窗口，输入whoami即可看到答案。哈哈，开玩笑啦。我是谁？我时常思考这个问题，是未来麻省或者斯坦福的顶尖学者？是微软或者谷歌所找的IT精英？还是即将走向华尔街之狼的商业大亨？亦或是能够开创一个譬如Apple一样的Banana公司的创业人才？我想，我也会和绝大多数人一样，就是一个平凡的人。周杰伦曾说过：“我和大家一样都很平凡，只是学了一点音乐而已。”，当然也许是学了 ‘亿’点音乐。平凡没什么不好，“平凡铸就伟大，英雄来自人民”，平凡的人我想也可以很了不起！我是一个大学生，身旁有一群志同道合、可爱的伙伴，背后有默默支持我的亲人朋友，我有自己的梦想，有自己的热爱，我是一个平凡的人，同时也在体验与探索着这个奇幻与美妙的世界。</p>
<p><img src="https://s2.loli.net/2024/02/09/4nmdNhF86Syu7sc.jpg" alt="博雅塔与未名湖.jpg"></p>
<hr>
<h2 id="展望与期待"><a href="#展望与期待" class="headerlink" title="展望与期待"></a>展望与期待</h2><p>还是来展望一下2024年吧。</p>
<blockquote>
<p>找到一份满意的实习<br>去更多的地方探索游玩<br>认识更多的伙伴朋友</p>
</blockquote>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2023已悄然退出了舞台，马上就迎来2024的新年了。此刻，大街小巷张灯结彩，家家户户欢聚团圆，伴随着新年的钟声与鞭炮声，告别冬天的寒冷，迎接春天，来年依旧迎花开！新年快乐，一起加油呀！<br><img src="https://s2.loli.net/2024/02/10/i4WunNQo8Y2rbJR.jpg" alt="新年快乐！.jpg"></p>
<h2 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h2><p>最后放一些补图<br><img src="https://s2.loli.net/2024/02/09/kPrYiKWv3H7d215.jpg" alt="西湖小船.jpg"><br><img src="https://s2.loli.net/2024/02/09/fqzrmDjBM8CbAUg.jpg" alt="黄浦江深.jpg"><br><img src="https://s2.loli.net/2024/02/09/lJVXWeA5c4RES9M.jpg" alt="天津之眼.jpg"><br><img src="https://s2.loli.net/2024/02/09/yo6xbZwr3ReLf9G.jpg" alt="东堤公园.jpg"></p>
<p><img src="https://s2.loli.net/2024/02/09/E17isnvxweBaoFZ.jpg" alt="和优秀大佬们交流学习.jpg"><br><img src="https://s2.loli.net/2024/02/09/Yp4ATOvjGJudSkI.jpg" alt="字节伙食（北信科得卖10W）.jpg"><br><img src="https://s2.loli.net/2024/02/10/ciRhp7dsED2kJS9.jpg" alt="校园迷你马拉松.jpg"><br><img src="https://s2.loli.net/2024/02/10/BYhN7AOq8JR3VTP.jpg" alt="马路杀手上线.jpg"><br><img src="https://s2.loli.net/2024/02/09/UCWnfMJDHsxqOya.jpg" alt="只要你相信.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构——堆（向上调整法/向下调整法、建堆、堆排序、TopK问题）</title>
    <url>/2023/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%A0%86%EF%BC%88%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E6%B3%95-%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E6%B3%95%E3%80%81%E5%BB%BA%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81TopK%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="一、堆的基本概念和性质"><a href="#一、堆的基本概念和性质" class="headerlink" title="一、堆的基本概念和性质"></a>一、堆的基本概念和性质</h2><p>堆(heap)是一个<strong>完全二叉树</strong>，并且满足以下性质：<strong>每个节点的值都大于或等于其左右孩子节点的值，称为大根堆；或是每个节点的值都小于或等于其左右孩子的值，称为小根堆。</strong>  </p>
<p>复习：<span style="background-color: yellow;">完全二叉树</span><br>设二叉树的深度为h，除第h层外，其它各层（1 ~ h-1）的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。  </p>
<p>完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/gay81A3SlPc7Ndu.png" alt="完全二叉树.png"></p>
<span id="more"></span>  
<p>非完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/fmoSUkZwAWRg37q.png" alt="非完全二叉树.png"><br>堆：<br><img src="https://s2.loli.net/2023/10/07/hdSCfPibUsvIuBJ.png" alt="堆.png"><br><strong>从堆的概念不难看出，大根堆堆顶为集合的最大值，小根堆堆顶为集合的最小值</strong>  </p>
<p>  <strong>堆的存储</strong><br>  那么在数据结构中，我们如何存储堆呢？由于堆是一个完全二叉树，这就决定了每个节点的相对位置是固定的，所以这里我们不同于以往的用链表来存储，我们采用一种<span style="background-color: yellow;">船新的存储方式：用一个一维数组来存储堆</span>。为了方便操作，我们采用下标从1开始，<strong>下标1的位置就是根节点，节点x的左儿子是2x,节点x的右儿子是2x + 1</strong><br> <img src="https://s2.loli.net/2023/10/07/k3CJw2iUjxZs4hE.png" alt="堆的存储.png"></p>
<h2 id="二、堆的两个基本操作（down、up）"><a href="#二、堆的两个基本操作（down、up）" class="headerlink" title="二、堆的两个基本操作（down、up）"></a>二、堆的两个基本操作（down、up）</h2><h3 id="1、向上调整法"><a href="#1、向上调整法" class="headerlink" title="1、向上调整法"></a>1、向上调整法</h3><p>向上调整法用于除最后一个元素意外，其余节点均满足堆的性质时，我们用向上调整法将最后一个节点调整成堆。具体做法如下（以小跟堆为例）：<br><strong>从最后一个节点开始，比较该节点和其父节点的大小，如果该节点的值小于父节点的值，则进行交换。一直到该节点到堆顶或者该节点的值大于等于父节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/yMtiC7u8UkjVbrf.png" alt="向上调整法.png">  </p>
<p>那么，具体代码该如何实现呢？我们知道了从父亲推出左右儿子的关系为x &#x3D; 2x 和 x &#x3D; 2x + 1，那知道当前节点的下标，可以反推其父亲节点的下标。假设该节点下标为u，则其父亲节点下标为u &#x2F; 2或者是(u - 1) &#x2F; 2，那经过向下取整的规则后，其父节点下标可以直接写为u &#x2F; 2,那我们就可以写出代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h[]为堆（数组）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u &gt; <span class="number">1</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]&gt;)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[u / <span class="number">2</span>]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、向下调整法"><a href="#2、向下调整法" class="headerlink" title="2、向下调整法"></a>2、向下调整法</h3><p>向下调整法是从上向下调，该方法在建堆，解决排序等问题上有重大作用，所以应当重点掌握。对于采用向下调整法来说，应该满足条件：该根节点左右子树均为大堆或者均为小堆，只有根节点不满足，这时候我们采用向下调整法来将整个树调整成堆。具体做法如下（以小根堆为例）：<br><strong>从根节点开始，比较该节点与其左右孩子节点的值，如果该节点的值大于孩子节点的值，将其与左右孩子中较小的那个进行交换，一直到该节点为最后一层或者该节点的值小于等于左右孩子节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/25mYzOR7TAHBbrD.png" alt="向下调整法.png"></p>
<p>代码实现思路：从根节点，左右孩子节点中比较出最大的那个，如果最大的那个节点是孩子节点，则将根节点与孩子节点进行交换，假设根节点小标为u，则左孩子节点下标为2u,右孩子节点下标为2u + 1,假设节点数为my_size，则代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个变量t来表示最大值下标</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有左孩子，并且左孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有右孩子，并且右孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、堆的一些操作"><a href="#三、堆的一些操作" class="headerlink" title="三、堆的一些操作"></a>三、堆的一些操作</h2><p><strong>1、插入一个数</strong><br>该操作其实就是向上调整法的应用，将该数插入到数组末尾，然后进行向上调整操作即可。  </p>
<blockquote>
<p>heap[my_size++] &#x3D; x; up(my_size);  </p>
</blockquote>
<p><strong>2、求集合当中的最值</strong><br>直接返回堆顶元素即可。</p>
<blockquote>
<p>return h[1];  </p>
</blockquote>
<p><strong>3、删除集合中的最值</strong><br>删除集合中的最值我们采用覆盖的方法，即将最后一个节点的值覆盖到根节点的值，再将my_size–,然后对新的根节点进行向下调整操作即可。为什么要这么做呢？<strong>因为我们使用数组储存的堆结构，而删除第一个元素的话，后面的元素都会进行改变且结构被破坏，比较麻烦。而如果我们用最后一个元素去覆盖的话，前面的其他元素不需要进行改变且维持原有堆结构保持不变（除了新覆盖的根节点不满足），我们只需要将根节点down()操作一下即可，非常方便。</strong><br><img src="https://s2.loli.net/2023/10/07/WVLJAjKUk6vMzql.png" alt="删除集合中的最值.png"></p>
<blockquote>
<p>heap[1] &#x3D; heap[my_size–]; down(1);  </p>
</blockquote>
<p><strong>4、删除任意一个元素</strong><br>删除任意一个元素，假设删除第k个元素，则需要将末尾元素覆盖第k个元素，然后将,my_size–，然后得分情况（以小跟堆为例），如果是变大的话，需要down()一下，如果是是变小的话，需要down()一下，这里我们直接将两个都写，因为这里两个中只会执行一个。</p>
<blockquote>
<p>heap[k] &#x3D; heap[my_size–]; up(k); down(k);  </p>
</blockquote>
<p><strong>5、修改任意一个元素</strong><br>修改任意一个元素与前面同理。</p>
<blockquote>
<p>heap[k] &#x3D; x; down(k); up(k);</p>
</blockquote>
<h2 id="四、堆排序、TopK问题"><a href="#四、堆排序、TopK问题" class="headerlink" title="四、堆排序、TopK问题"></a>四、堆排序、TopK问题</h2><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>知道了堆的基本性质和操作，那给定一个无序数组如何将其建成大堆呢？我们可以用向上调整法和向下调整法。这里我们采用<strong>向下调整法建堆，因为其时间复杂度优于一个一个插入的向上调整法（时间复杂度为O（NlogN）。用向下调整法建堆的时间复杂度为O（N）</strong>，具体建堆过程分析如下：<br>我们从最后一个非叶子结点开始递归向上进行down操作（叶结点自然不用调整），假设总共有n个节点,则最后一个非叶子节点下标为n &#x2F; 2，则我们从n &#x2F; 2处开始进行向下调整即可。<br><img src="https://s2.loli.net/2023/10/07/8IicoWXypqMbSrx.png" alt="建堆过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向下调整时间复杂度分析</strong>：<br>假设右n个节点，从倒数第二层开始，该层有n&#x2F;4个节点，每个节点需要调一次，倒数第三层，该层有n&#x2F;8个节点，每个节点需要调两次,依次类推，时间复杂度为：</p>
<blockquote>
<p>n&#x2F;4 * 1 + n&#x2F;8 * 2 + n&#x2F;16 * 3 + n&#x2F;32 * 4 +…<br>&#x3D; n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …)<br>令S &#x3D; 1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^5 + …<br>则2S &#x3D; 1&#x2F;2 + 2&#x2F;2^2 + 3&#x2F;2^3 + 4&#x2F;2^4 + …<br>2S - S &#x3D; S &#x3D;1&#x2F;2 + 2&#x2F;2^2 + 1&#x2F;2^3 + 1&#x2F;2^4 + … &lt; 1<br>则n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …) &lt; n</p>
</blockquote>
<p>故时间复杂度小于N,进一步分析可知<strong>向下调整建堆的时间复杂度为O（N）</strong></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们来利用堆的性质来进行排序。如果要排升序或者降序，我们应该建大堆还是小堆呢？答案是<strong>排升序，建大堆；排降序，建小堆</strong>。原因是我们要在原数组上进行排序的话，以排升序为例，我们假如建小堆，那么每次的根节点将是当前最小值，而下一步的话最小值根节点为左孩子或者右孩子，这样继续排下去的话，整个堆的结构会被打乱，无法满足要求。而我们采用前面删除的思想，建大堆。每次只需将堆顶和堆底元素进行交换，然后对堆顶进行向下调整，每次都能将最大值放入后面正确的位置，且前面的堆结构维持不变。具体过程如下：<br><img src="https://s2.loli.net/2023/10/07/sL8AXGUB1kViafF.png" alt="堆排序过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(my_size &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[<span class="number">1</span>], h[my_size--]);</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序时间复杂度：向下调整N次，每次调整为O(logN),建堆为O(N)，则为O(N + NlogN),即为O(NlogN);</strong></p>
<h3 id="Topk问题"><a href="#Topk问题" class="headerlink" title="Topk问题"></a>Topk问题</h3><p>接下来我们来看一个经典问题：<span style="background-color: yellow;">Topk问题</span></p>
<p><strong>题目：输入一个长度为 n的整数数列，从小到大输出前 m小的数。</strong><br>此题我们可以用快排等排序来做，  今天我们用堆来做（堆在处理海量数据时具有重要应用）<br>思路：题目要求我们从小到大输出前m小的数,那么我们可以构造一个小根堆，每次取出堆顶元素即可。具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], MySize;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用t来表示三个点里最小值的编号</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有左孩子，并且左孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有右孩子，并且右孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t= <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    MySize = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从n / 2，即最后一个孩子的父亲开始调。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        h[<span class="number">1</span>] = h[MySize--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>本篇文章主要介绍了堆的基本概念和性质</li>
<li>重点介绍了堆的两个基本操作：<strong>向上调整法(up)和向下调整法(down)</strong> ，向下调整法的应用较多，应当重点掌握。</li>
<li>接着我们介绍了基于up和down两种操作的一些堆能实现的操作，<strong>插入一个数、求集合中的最值、删除集合中的最值、删除任意一个元素、修改任意一个元素</strong> ，以及删除时的覆盖思想。</li>
<li>重点分析了建堆的过程：<strong>堆排序和Topk问题</strong>，了解了建堆的方法以及时间复杂度，<strong>一个一个元素插入+向上调整法建堆的时间复杂度是O(N*longN),而从最后一个非叶子节点开始递归向上进行向下调整法建堆的时间复杂度为O(N)</strong> 。</li>
<li>了解了堆的应用，堆排序、Topk问题，知道<strong>排升序，建大堆；排降序，建小堆</strong>。堆在Topk问题上重要应用，我们只需要关注前k个数。堆还有很多重要作用，海量数据时Topk的问题，外排序等内容。</li>
<li><span style="background-color: yellow;">一个元素要成为Topk，经历的过程可不简单，那么我们何尝不是如此？所以，加油吧，朋友。</span><blockquote>
<p>以上就是关于堆的入门的全部内容了，如果文章有什么错误或者遇到什么问题，欢迎随时和我交流联系。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>探究C++中的移动语义（左值、右值、引用、move）</title>
    <url>/2024/04/17/%E6%8E%A2%E7%A9%B6C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E3%80%81move%E3%80%81forward/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/04/22/D8iWHj9V6PknflQ.png"></p>
<h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><p>普通构造与移动语义的时间对比</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个大数据量的字符串</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dataSize = <span class="number">1000000</span>; <span class="comment">// 1,000,000 characters</span></span><br><span class="line">    <span class="type">char</span>* largeString = <span class="keyword">new</span> <span class="type">char</span>[dataSize + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataSize; ++i) &#123;</span><br><span class="line">        largeString[i] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 填充字符 &#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    largeString[dataSize] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结束符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量使用移动构造的执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> startMoveConstructor = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">temp</span><span class="params">(largeString)</span></span>;</span><br><span class="line">    MyString moved = std::<span class="built_in">move</span>(temp);</span><br><span class="line">    <span class="keyword">auto</span> endMoveConstructor = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationMoveConstructor = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endMoveConstructor - startMoveConstructor);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by move constructor: &quot;</span> &lt;&lt; durationMoveConstructor.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量使用拷贝构造的执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> startCopyConstructor = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">tempCopy</span><span class="params">(largeString)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">copied</span><span class="params">(tempCopy)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> endCopyConstructor = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationCopyConstructor = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endCopyConstructor - startCopyConstructor);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by copy constructor: &quot;</span> &lt;&lt; durationCopyConstructor.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量使用移动赋值的执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> startMoveAssignment = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">anotherTemp</span><span class="params">(largeString)</span></span>;</span><br><span class="line">    MyString assigned;</span><br><span class="line">    assigned = std::<span class="built_in">move</span>(anotherTemp);</span><br><span class="line">    <span class="keyword">auto</span> endMoveAssignment = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationMoveAssignment = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endMoveAssignment - startMoveAssignment);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by move assignment: &quot;</span> &lt;&lt; durationMoveAssignment.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量使用拷贝赋值的执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> startCopyAssignment = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="function">MyString <span class="title">anotherTempCopy</span><span class="params">(largeString)</span></span>;</span><br><span class="line">    MyString assignedCopy;</span><br><span class="line">    assignedCopy = anotherTempCopy;</span><br><span class="line">    <span class="keyword">auto</span> endCopyAssignment = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationCopyAssignment = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endCopyAssignment - startCopyAssignment);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by copy assignment: &quot;</span> &lt;&lt; durationCopyAssignment.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] largeString; <span class="comment">// 释放动态分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量返回值优化的执行时间（使用移动语义）</span></span><br><span class="line">    <span class="keyword">auto</span> startReturnFromFunctionWithMove = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    MyString returnedFromFunction = <span class="built_in">getMyString</span>(); <span class="comment">// 假设有一个函数 getMyString() 返回 MyString</span></span><br><span class="line">    <span class="keyword">auto</span> endReturnFromFunctionWithMove = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationReturnFromFunctionWithMove = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endReturnFromFunctionWithMove - startReturnFromFunctionWithMove);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by return from function with move: &quot;</span> &lt;&lt; durationReturnFromFunctionWithMove.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量返回值优化的执行时间（不使用移动语义）</span></span><br><span class="line">    <span class="keyword">auto</span> startReturnFromFunctionWithoutMove = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    MyString returnedFromFunctionWithoutMove = <span class="built_in">getMyStringWithoutMove</span>(); <span class="comment">// 使用没有移动语义的返回</span></span><br><span class="line">    <span class="keyword">auto</span> endReturnFromFunctionWithoutMove = high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> durationReturnFromFunctionWithoutMove = <span class="built_in">duration_cast</span>&lt;microseconds&gt;(endReturnFromFunctionWithoutMove - startReturnFromFunctionWithoutMove);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time taken by return from function without move: &quot;</span> &lt;&lt; durationReturnFromFunctionWithoutMove.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>得出的结果如下：<br><img src="https://s2.loli.net/2024/04/22/FfGYodwnb4iDNuH.png"><br>可以看出，使用移动语义后能提高我们程序的效率，这就是为什么C++11以后会有语义的概念，其实主要都是为了提升效率而不断引入的。接下来我们一步一步探究其中的奥秘，首先来看一些概念</p>
<h1 id="一、左值与右值"><a href="#一、左值与右值" class="headerlink" title="一、左值与右值"></a>一、左值与右值</h1><p><strong>C++中的表达式，要么是左值，要么是右值</strong>。左值是可寻址的变量，有持久性；而右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。<br>通常情况讲，左值就是能放在等号左边的表达式，如</p>
<blockquote>
<p>int i &#x3D; 1;<br>i &#x3D; 2;  </p>
</blockquote>
<p>这里的变量i就是左值，他是可修改的，但是加上const之后，他就具有常量属性，不可修改</p>
<blockquote>
<p>const int i &#x3D; 1;<br>i &#x3D; 2;&#x2F;&#x2F;错误。因为i具有常量属性，不可修改    </p>
</blockquote>
<p>能用到左值的运算符通常有：</p>
<ul>
<li>赋值运算符<blockquote>
<p>int a;<br>a &#x3D; 4;&#x2F;&#x2F;整个赋值语句的结果仍然是左值</p>
</blockquote>
</li>
<li>取地址 &amp;<blockquote>
<p>int a &#x3D; 4;&#x2F;&#x2F;变量就是左值<br>&amp;a;</p>
</blockquote>
</li>
<li>下标，如string, vector下标[]都需要左值<blockquote>
<p>string s &#x3D; “I’m KK”;<br>s[0];<br>vector<int>::iterator iter;<br>iter++; iter–  </int></p>
</blockquote>
</li>
<li>通过看运算符在字面量上的操作判断<blockquote>
<p>i++;&#x2F;&#x2F;正确<br>9++;&#x2F;&#x2F;错误</p>
</blockquote>
</li>
</ul>
<p><strong>而不是左值的，就是右值，右值也会被称为临时值</strong></p>
<h1 id="二、引用的分类"><a href="#二、引用的分类" class="headerlink" title="二、引用的分类"></a>二、引用的分类</h1><h2 id="左值引用（绑定到左值上）带一个“-amp-”"><a href="#左值引用（绑定到左值上）带一个“-amp-”" class="headerlink" title="左值引用（绑定到左值上）带一个“&amp;”"></a>左值引用（绑定到左值上）带一个“&amp;”</h2><p>我们希望引用的对象可改变值，就会用到左值引用。左值引用只能绑定到左值上</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; b&#123;a&#125;; <span class="comment">//正确，a是左值，b可以绑定</span></span><br><span class="line"><span class="type">int</span>&amp; c;<span class="comment">//错误，引用必须要初始化</span></span><br><span class="line"><span class="type">int</span>&amp; d = <span class="number">1</span>;<span class="comment">//错误，左值引用不能绑右值</span></span><br></pre></td></tr></table></figure>
<h2 id="cosnt引用-常量引用"><a href="#cosnt引用-常量引用" class="headerlink" title="cosnt引用(常量引用)"></a>cosnt引用(常量引用)</h2><p>常量引用也是左值引用，但是我们希望引用的对象是不改变的,const引用可以绑左值，右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; a = t;</span><br><span class="line">a = <span class="number">2</span>;<span class="comment">//错误，a具有const属性，不是可修改的左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = <span class="number">2</span>;<span class="comment">//正确，const引用可以绑定到右值上,这里就区别于普通左值引用了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    其实“const int&amp; b = 10;”这句发生了这个事情:</span></span><br><span class="line"><span class="comment">    int tmp = 2;//这里的tmp是一个临时变量</span></span><br><span class="line"><span class="comment">    const int&amp; b = tmp;</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<h2 id="右值引用（绑定到右值上）带”-amp-amp-”"><a href="#右值引用（绑定到右值上）带”-amp-amp-”" class="headerlink" title="右值引用（绑定到右值上）带”&amp;&amp;”"></a>右值引用（绑定到右值上）带”&amp;&amp;”</h2><p>右值引用主要是来绑定到那些<strong>临时的或者即将销毁的对象</strong>，右值引用只能绑右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a = <span class="number">1</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; b = i;<span class="comment">//错误，右值引用不能绑左值</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; c = i * <span class="number">100</span><span class="comment">//正确，i * 100 结果是右值</span></span><br></pre></td></tr></table></figure>
<h2 id="小结几点"><a href="#小结几点" class="headerlink" title="小结几点"></a>小结几点</h2><ul>
<li>（1）前置递增减运算符与后置递增减运算符的区别<br>前置递增减运算法是左值表达式，因为++i是直接将i变量+1然后再返回i本身，而后置递增运算符是右值表达式，因为i++是先产生一个临时变量来保存i的值用于使用目的，再给i+1，之后系统再释放这个临时变量,临时变量被释放掉了，不能再被赋值;<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">7</span>;</span><br><span class="line">(++i) = <span class="number">20</span>;<span class="comment">//正确，i被赋值成20</span></span><br><span class="line">(i++) = <span class="number">10</span>;<span class="comment">//错误,表达式必须是可修改的左值</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; a = j++;<span class="comment">//可以，成功绑定右值,但此后a的值和j没关系</span></span><br><span class="line"><span class="type">int</span>&amp; b = j++<span class="comment">//不可以，左值引用不能绑右值表达式</span></span><br></pre></td></tr></table></figure></li>
<li>(2) &amp;&amp;r1绑定到了右值，但r1是本身是左值(看成一个变量)</li>
<li>(3) 所有变量都要看成左值，因为他们是有地址的</li>
<li>(3)临时对象都是右值</li>
</ul>
<h1 id="三、探究临时对象"><a href="#三、探究临时对象" class="headerlink" title="三、探究临时对象"></a>三、探究临时对象</h1><p>前面的例子中我们提到临时对象，临时对象的产生往往容易被我们忽略，而产生临时对象会消耗资源和空间，这对于我们的程序，应该是尽量去避免产生临时对象以达到提高、优化性能的目的。<br>以下是一些常见的会产生临时值的地方：</p>
<ul>
<li>函数传参<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="string">&quot;some temporary string&quot;</span>);<span class="comment">//这里虽然传的是常量，但是C++中大概率还是产生一个临时变量来复制</span></span><br></pre></td></tr></table></figure></li>
<li>初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">x</span>());<span class="comment">//这里会初始化一个临时的x，然后被复制进vector</span></span><br></pre></td></tr></table></figure></li>
<li>类型转换产生<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TValue sum;</span><br><span class="line">sum = <span class="number">100</span>;<span class="comment">//这里会产生一个临时的TValue的对象来进行调用一个拷贝赋值</span></span><br></pre></td></tr></table></figure></li>
<li>函数返回对象时<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TValue <span class="title">doubled</span><span class="params">(TValue&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TValue tmp;</span><br><span class="line">    tmp.x = t.x * <span class="number">2</span>;</span><br><span class="line">    tmp.y = t.y * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;<span class="comment">//这里会产生一个临时对象用于返回，tmp是左值，但优先移动，不支持移动时仍可复制。但要注意，现在的大多编译器会进行优化</span></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">* 表达式赋值</span><br><span class="line">```cpp</span><br><span class="line">a = b + c; <span class="comment">// b+c是一个临时值, 然后被赋值给了a  </span></span><br><span class="line">a = b + c + d; <span class="comment">//c+d是一个临时变量, b+(c+d)是另一个临时变量</span></span><br></pre></td></tr></table></figure></li>
<li>后置递增减运算符<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x++; <span class="comment">// 前面提到的，先产生一个临时变量来保存i的值用于使用目的，再给i+1，之后系统再释放这个临时变量,临时变量被释放掉了，不能再被赋值;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、对象移动与move-的作用"><a href="#四、对象移动与move-的作用" class="headerlink" title="四、对象移动与move()的作用"></a>四、对象移动与move()的作用</h1><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><p>什么是对象移动？对象移动其实就是把一个不想用了的对象A(临时值那些)中的一些有用的数据提取出来，在构建新对象B时就不需要重新构建对象中的所有数据————而是直接从A中提取出来，这样就避免了拷贝复制浪费资源与效率</p>
<h2 id="move-函数"><a href="#move-函数" class="headerlink" title="move()函数"></a>move()函数</h2><p>move()函数的作用就是将一个左值强制转换成右值，这样就能使得一个右值引用能绑定到这个转换成的右值对象了。请注意：<strong>C++中的move函数只是做了类型转换，并不会真正的实现值的移动！！！</strong> 要实现真正的移动，得自己手动重载移动构造函数和移动复制函数。<strong>我们需要在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong><br>不过实际上，通常情况下C++编译器会默认在用户自定义的class和struct中生成移动语义函数。这样的前提是我们自己没有主动定义该类的拷贝构造等函数。</p>
<p>需要注意的点是：</p>
<ul>
<li>对象在被move后，并没有被立即析构，而是在其离开作用域后才会被析构，如果此时继续使用被析构的对象的一些变量，会发生一些意想不到的错误。因此一般需要手动将源对象的值置空，以防止同一片内存区域被多次释放！</li>
<li>如果我们没有提供移动构造函数，只提供了拷贝构造函数，std::move()会失效但是不会发生错误，因为编译器找不到移动构造函数就去寻找拷贝构造函数，这也是拷贝构造函数的参数是const T&amp;常量左值引用的原因！</li>
<li>c++11中的所有容器都实现了move语义</li>
<li>一些基本类型使用move还是会被复制，因为它们没有对象的移动构造函数，所以move对于含有内存，文件句柄等资源对象更有意义</li>
</ul>
<h1 id="五、移动构造函数与移动赋值运算符"><a href="#五、移动构造函数与移动赋值运算符" class="headerlink" title="五、移动构造函数与移动赋值运算符"></a>五、移动构造函数与移动赋值运算符</h1><p>下面给出一个使用移动构造和移动赋值运算符的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(_data, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            *_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;built this object, address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destruct this object, address: &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Move constructor</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">        : _data(str._data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move this object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;<span class="comment">//这一步很重要</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy assignment</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)<span class="comment">//避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str._data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_data, str._data);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Move assignment</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span> = (MyString&amp;&amp; str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)<span class="comment">//避免自我赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] _data;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;<span class="comment">//不再指向之前的资源</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_move</span><span class="params">(MyString&amp;&amp; obj)</span> </span>&#123;</span><br><span class="line">	<span class="function">MyString <span class="title">a_obj</span><span class="params">(std::move(obj))</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;move function, address: &quot;</span> &lt;&lt; &amp;a_obj &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyString obj&#123; <span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_move</span>(std::<span class="built_in">move</span>(obj));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==================== end ==================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果如下:  </p>
<p><img src="https://s2.loli.net/2024/04/22/aZKqYXgB2TuFbfx.png"></p>
<p>观察输出结果，可以验证我们上诉所说的<br>这里我们需要注意：<strong>在移动构造函数和移动赋值函数中，我们将当前待移动对象的资源赋值为了空（str._data&#x3D;nullptr），这里就是我们手动实现了资源的移动！</strong><br>假如尝试修改两个地方，将导致报错：</p>
<ul>
<li>使用资源被move后的对象<br>在main函数中添加如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyString obj&#123; <span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">f_move</span>(std::<span class="built_in">move</span>(obj));</span><br><span class="line">    std::cout &lt;&lt; obj._data &lt;&lt; std::endl; <span class="comment">// danger!</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==================== end ==================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
会导致报错与程序崩溃：</li>
</ul>
<p><img src="https://s2.loli.net/2024/04/22/ELGHUbxXiOBp4eJ.png" alt="image.png"><br>因为此时obj中的内容已经为空了！</p>
<ul>
<li>在实现移动构造函数时不赋值为nullptr<br>将这里注释掉：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">    : _data(str._data) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;move this object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//str._data = nullptr;//这一步很重要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
程序崩溃：<br><img src="https://s2.loli.net/2024/04/22/Fh5WiAP8U6vKjX7.png" alt="image.png"></li>
</ul>
<p>因为我们没将源对象指针置空，两个指针指向同一块资源，当他们生命周期结束后，都会释放同一块资源，导致两次释放！</p>
<blockquote>
<p>参考资料：<br>《C++新经典》——王建伟<br> 深入理解C++中的move和forward ——腾讯云开发者 张凯</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>设计和使用Qt Designer Widget插件时遇到的问题记录及解决方案</title>
    <url>/2024/04/05/%E8%AE%BE%E8%AE%A1%E5%92%8C%E4%BD%BF%E7%94%A8Qt-Designer-Widget%E6%8F%92%E4%BB%B6%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2024/04/05/H1euUO5VXyZgMqR.png" alt="自定义插件"><br>最近在学习Qt中的自定义插件和库，然后在设计和使用Qt Desiger Widget插件时，发现无法找到我自己设计的Widget插件，于是分析和查询了一番，又发现了好多问题，最后一步一步分析与查询，最终成功解决了问题，成功使用自己的自定义插件，在这过程中也对一些构建配置、链接库有了更深的理解。</p>
<span id="more"></span>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Qt自定义的widget插件无法在Designer中显示<br><img src="https://s2.loli.net/2024/04/05/tsF7wNa5ufIni8x.png" alt="没有显示.png"><br>首先检查自己项目文件夹中release版本，发现里面只有.dll文件而没有.lib文件，于是我怀疑是不是构建配置的环境有问题，<strong>查寻帮助文档以及一些提示，发现Qt自带默认的编译器是 MinGW，Windows 平台 Qt Creator 是由 Visual Studio 编译生成的程序（MSVC编译）</strong>，两个编译器不一样，这样在就导致在Qt Designer无法加载出来自定义好的插件。<br>那么如何才能在Qt Creator中使用自定义的插件呢？目前得知两种方法：</p>
<ul>
<li><strong>一是用MinGW编译一一个Qt Creator，这样Qt Creator就能加载出MinGW编译出来的插件了</strong></li>
<li><strong>二是使用MSVC版本来构建，用其重新编译一下自定义的插件，这样就能直接加载了</strong></li>
</ul>
<p>这里我使用的是第二种方法。</p>
<h2 id="MinGW和MSVC"><a href="#MinGW和MSVC" class="headerlink" title="MinGW和MSVC"></a>MinGW和MSVC</h2><p>搜寻资料发现，当用<strong>MinGW编译时，会生成.dll文件和.a文件，而当用MSVC编译时，会生成.dll文件和.lib文件</strong>，这也就是为什么一开始我的release文件夹中没有找到.lib文件的原因。</p>
<ul>
<li>首先检查配置，打开Qt Creator–&gt;工具–&gt;选项–&gt;构建–&gt;Kits</li>
<li>点击Compilers，查看是否有VS的MSVC版本</li>
</ul>
<p><img src="https://s2.loli.net/2024/04/05/wMuGyKIjxhJTzBb.png" alt="Compilers"></p>
<ul>
<li>点击Debuggers，查看是否有对应的Windows Kits</li>
</ul>
<p><img src="https://s2.loli.net/2024/04/05/3WE17mJnxDBHliA.png" alt="Debuggers"><br>(因为VS我之前下载过，所以上面两个都自动检测到了，如果没有的话得自己下一个VS配个环境), </p>
<ul>
<li>点击Qt Version， 查看是否有MSVC的版本，发现没有，则接下来就去安装对应的组件</li>
</ul>
<p><img src="https://s2.loli.net/2024/04/05/xadUeY3CfJX1r5k.png" alt="Qt Version"></p>
<h2 id="MaintenanceTool使用与镜像源"><a href="#MaintenanceTool使用与镜像源" class="headerlink" title="MaintenanceTool使用与镜像源"></a>MaintenanceTool使用与镜像源</h2><ul>
<li>打开MaintenanceTool.exe（通常在Qt安装目录下能够找到）</li>
<li>推荐使用国内镜像源(不用也可以，但时常下载缓慢甚至出错)：点击设置–&gt;档案资料库–&gt;用户定义的档案资料库–&gt;添加–&gt;粘贴镜像源的地址（可在<a href="https://download.qt.io/static/mirrorlist/">https://download.qt.io/static/mirrorlist/</a> 里选择，我这里用的是中科大的）–&gt;点击条件测试–&gt;显示成功则没问题<br><img src="https://s2.loli.net/2024/04/05/URxydhcbq8VTn23.png" alt="镜像源"></li>
<li>点下一步到选择组件，<strong>注意把Archive勾上然后筛选</strong>，完成后选择对应版本的Qt（如我的是Qt6.2.4）,选择对应的MSVC组件，勾上后选择下一步，安装然后等待完成即可</li>
<li><img src="https://s2.loli.net/2024/04/05/CaTKAj3n4zy6Rxl.png" alt="安装组件"></li>
</ul>
<h2 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h2><p>安装成功后，我们回到Qt Creator的Kits，<strong>在Qt Version中添加刚下载好的MSVC版本，然后在kits中配置好编译环境</strong><br><img src="https://s2.loli.net/2024/04/05/DTbK3pfkGl4MmdI.png" alt="配置MSVC"><br>接下来我们打开原来的<strong>自定义插件项目</strong>，执行对应的release编译即可生成MSVC版本的文件，这下在release文件夹里面能够看到.dll文件和.lib文件了。把.dll文件拷贝到Qt\Tools\QtCreator\bin\plugins\designer下，之后我们打开一个项目，打开Qt Designer就能看到并使用自定义的插件了。  </p>
<p><img src="https://s2.loli.net/2024/04/05/Mmx9EcIYtefAOXR.png" alt="组件成功显示"><br>但是这样项目还运行不起来，因为我们没有把lib库给这个项目，导致无法找到，接下来执行步骤：</p>
<ul>
<li>把.dll文件和.lib以及生成的.h文件拷贝到使用项目的目录中去，我们可以建一个目录命名为lib用来存放</li>
<li>在Qt Creator中，右击项目选择添加库，然后按照说明选择刚才拷贝的.lib以及路径，点击确定</li>
<li>最后<strong>右键项目run qmake</strong>一下然后执行编译即可成功构建项目并运行（这里需要注意的，是用release版本的库，那使用时就得也用release编译，这样才能链接上）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>试</title>
    <url>/2022/10/15/%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/08/test/test/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>

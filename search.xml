<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“落子无悔，抉择本身就是向前”——2022年度总结</title>
    <url>/2022/12/29/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h1><p>岁月不居，时节如流。一转眼，2022年已经来到了尾声，这一年里，经历了高考，度过了18岁的生日，踏上了大学的校园，遇见了许许多多的人，也经历了许许多多的事。这一年，对我来说，没有所谓的轰轰烈烈， 也没有所谓的刻骨铭心，吃过很多亏，做过很多傻事，当然，我也收获很多。年末之际，对此做些回顾与梳理，不失为一种享受，也算是对自己的反思总结。</p>
<span id="more"></span>
<h1 id="2、2022回顾与总结"><a href="#2、2022回顾与总结" class="headerlink" title="2、2022回顾与总结"></a>2、2022回顾与总结</h1><h2 id="2-1、新阶段"><a href="#2-1、新阶段" class="headerlink" title="2.1、新阶段"></a>2.1、新阶段</h2><p>9月，踏上了大学的校园，期待与憧憬，想象着我将在这里开始我的很多第一次。上大学前，身边充斥着各种各样的声音，也面临着各种各样的选择，所谓的虚荣？所谓的风光？是随波逐流，还是遵从内心？我，选择了后者。半年过去了，目前来说，我很庆幸当时的抉择。学生嘛，总有那么一点放荡不羁，总有那么一点桀骜不驯，何必那么在意他人的看法，选择适合自己的，就是最好的。我觉得，人总是要和时代挂钩的，总是要有联系的，倘若只闭门造车，也许只会是固步自封，倘若只是看到眼前，也许就会被时代给抛弃。上大学后，大学的生活和我曾经想象的不太一样，选择更多了，机会更多了，当然，挑战也更多了。如何规划自己的学习与生活？如何选择自己要走的道路？如何朝自己的方向努力？这是值得思考的问题。与其自我内耗，不如踏实奋斗，奋斗，仍然是最有意义的答案。<img src="https://s2.loli.net/2023/07/25/UnxACgVXrvRPTLD.jpg" alt="校园"></p>
<h2 id="2-2、学习与收获"><a href="#2-2、学习与收获" class="headerlink" title="2.2、学习与收获"></a>2.2、学习与收获</h2><p>大学的学习，与之前完全不同，变得更自由了，变得更深、更广了。编程的学习，也与其他的学习有所不同，近半年来，我切身地感受到编程的学习不仅要把理论搞懂，更重要的是动手实践，敲代码，解决问题，实践操作，这样学起来更加得舒服，也更扎实。大一上，学习到的知识与内容非常地多，而且非常地杂。但是，重点还是编程能力，数学思维，以及英语素养。高考完的暑假，我自学了C语言的一部分内容，这也让我能在专业课上学的比较舒服。在上了一些专业课与理论课后，我切身地感受到自学的重要性。因此，我开始真正学习到对自己有用的知识。学习，挺枯燥乏味的，但也可以是充满趣味的，通过学习C语言，我可以写出一两个小游戏，利用各种函数还能实现一些创意功能，如用蜂鸣函数，调整频率实现一首歌曲。<br><img src="https://s2.loli.net/2023/07/25/oiQy2I8fcYpTlXA.jpg" alt="教室学习"><br>近朱者赤，近墨者黑。很荣幸，通过iflab的面试，加入了这个大家庭。在社团中，导师们分享学习的经验与技巧，介绍各类比赛与经验，交流行业知识与现状，热心回答我们的疑问。因此，我也学到了很多，我创建了自己Github，有了自己的代码仓库，我也成功搭建部署了自己的个人博客，并且对行业的情况有了自己的认识与了解，通过FCC的学习打卡，对网页，前端内容有了一定的了解……相互学习是能促进进步的，别人有优点，去向他请教学习，何尝不是对自己的一种好处呢？勾心斗角，只会阻碍自己的进步。本学期，虽然离自己的学习目标还差挺大距离，但也收获许多，只能说，继续加油吧。<img src="https://s2.loli.net/2023/07/25/7BuPqwI1Zj69k2Y.jpg" alt="FCC打卡奖品"></p>
<h2 id="2-3、生活态度"><a href="#2-3、生活态度" class="headerlink" title="2.3、生活态度"></a>2.3、生活态度</h2><p>2022年，发生了许多变化，个人在变，社会在变，整个世界都在变。谁能想到，上半年还在高三的教室刷题的我，现在已经开始敲代码了呢？谁能想到，11月还在封控的疫情，12月年末就放开了呢？生活吧，总是会和你开玩笑，你得笑着回应它。不得不说，这一年里，我的人生观，价值观都在悄悄地发生着改变，除了学习呢，我也学会了很东西。这一年的疫情，压得人喘不过气来，有人抱怨，有人吐槽，社会就是如此，有些东西你无法改变，遵从自己的内心，同时做好自己，这不失为一种明智的选择。人，茫茫碌碌，到处奔波，但不应只有工作和学习。校园的健康跑，包括我在内挺多人吐槽的，但是3公里跑步的那些天，让我感觉非常舒服，睡眠质量提高了，学习效率也提升了，整个人的状态也是完全不同的。闲暇之余，我也会拿起吉他，随性弹唱一曲，哼唱两句：“长亭外，古道边，芳草碧连天……”。追逐浮世骄阳，也别错过人间万象。<img src="https://s2.loli.net/2023/07/25/RbGvO54aQ3UTuxD.jpg" alt="日落"></p>
<h1 id="3、展望2023"><a href="#3、展望2023" class="headerlink" title="3、展望2023"></a>3、展望2023</h1><p>2022年，有收获，也有遗憾，那就展望一下2023年<br><br>1.2023年开始持续输出博客，坚持输出达到20篇。<br><br>2.寒假学习数据结构与算法和C++，筑牢基础。<br><br>3.2023年一整年完成计算机四大件的学习，并尝试做一些中大型项目。<br><br>4.拿下四六级，驾驶证，取得3个以上计算机相关的比赛奖项。<br><br>5.阅读更多的书籍，专业书籍，如《C和指针》、《C陷阱与缺陷》、《大话数据结构》等与其他方面书籍。<br><br>6.游历北京城，参加户外实践，参观景点，各种展览，增长见识。<br><br>7.坚持体育锻炼，跑步、骑行、参加一些球类运动。</p>
<h1 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h1><p>悟已往之不谏，知来者之可追。新的一年要来了，过去的就让它过去吧，寒冬过后，都会回暖，2023，我们一起加油呀！新年快乐！</p>
<p><img src="https://s2.loli.net/2023/07/25/mVQKNhn1Zo4pkbY.webp" alt="烟花"></p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>first</title>
    <url>/2022/10/09/first/</url>
    <content><![CDATA[<p>不要强求不可知，要从已知推未知。</p>
]]></content>
  </entry>
  <entry>
    <title>photos</title>
    <url>/2022/10/15/photos/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>title</title>
    <url>/2022/10/13/title/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2022/11/04/test/</url>
    <content><![CDATA[<p><img src="https://s2.loli.net/2023/07/10/fyHQn2XGReotmVg.jpg" alt="阿狸的世界.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>试</title>
    <url>/2022/10/15/%E8%AF%95/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/11/08/test/test/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据结构——堆（向上调整法/向下调整法、建堆、堆排序、TopK问题）</title>
    <url>/2023/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%A0%86%EF%BC%88%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E6%B3%95-%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E6%B3%95%E3%80%81%E5%BB%BA%E5%A0%86%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81TopK%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="一、堆的基本概念和性质"><a href="#一、堆的基本概念和性质" class="headerlink" title="一、堆的基本概念和性质"></a>一、堆的基本概念和性质</h2><p>堆(heap)是一个<strong>完全二叉树</strong>，并且满足以下性质：<strong>每个节点的值都大于或等于其左右孩子节点的值，称为大根堆；或是每个节点的值都小于或等于其左右孩子的值，称为小根堆。</strong>  </p>
<p>复习：<span style="background-color: yellow;">完全二叉树</span><br>设二叉树的深度为h，除第h层外，其它各层（1 ~ h-1）的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树。  </p>
<p>完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/gay81A3SlPc7Ndu.png" alt="完全二叉树.png"></p>
<span id="more"></span>  
<p>非完全二叉树：<br><img src="https://s2.loli.net/2023/10/07/fmoSUkZwAWRg37q.png" alt="非完全二叉树.png"><br>堆：<br><img src="https://s2.loli.net/2023/10/07/hdSCfPibUsvIuBJ.png" alt="堆.png"><br><strong>从堆的概念不难看出，大根堆堆顶为集合的最大值，小根堆堆顶为集合的最小值</strong>  </p>
<p>  <strong>堆的存储</strong><br>  那么在数据结构中，我们如何存储堆呢？由于堆是一个完全二叉树，这就决定了每个节点的相对位置是固定的，所以这里我们不同于以往的用链表来存储，我们采用一种<span style="background-color: yellow;">船新的存储方式：用一个一维数组来存储堆</span>。为了方便操作，我们采用下标从1开始，<strong>下标1的位置就是根节点，节点x的左儿子是2x,节点x的右儿子是2x + 1</strong><br> <img src="https://s2.loli.net/2023/10/07/k3CJw2iUjxZs4hE.png" alt="堆的存储.png"></p>
<h2 id="二、堆的两个基本操作（down、up）"><a href="#二、堆的两个基本操作（down、up）" class="headerlink" title="二、堆的两个基本操作（down、up）"></a>二、堆的两个基本操作（down、up）</h2><h3 id="1、向上调整法"><a href="#1、向上调整法" class="headerlink" title="1、向上调整法"></a>1、向上调整法</h3><p>向上调整法用于除最后一个元素意外，其余节点均满足堆的性质时，我们用向上调整法将最后一个节点调整成堆。具体做法如下（以小跟堆为例）：<br><strong>从最后一个节点开始，比较该节点和其父节点的大小，如果该节点的值小于父节点的值，则进行交换。一直到该节点到堆顶或者该节点的值大于等于父节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/yMtiC7u8UkjVbrf.png" alt="向上调整法.png">  </p>
<p>那么，具体代码该如何实现呢？我们知道了从父亲推出左右儿子的关系为x &#x3D; 2x 和 x &#x3D; 2x + 1，那知道当前节点的下标，可以反推其父亲节点的下标。假设该节点下标为u，则其父亲节点下标为u &#x2F; 2或者是(u - 1) &#x2F; 2，那经过向下取整的规则后，其父节点下标可以直接写为u &#x2F; 2,那我们就可以写出代码了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h[]为堆（数组）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u &gt; <span class="number">1</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]&gt;)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[u / <span class="number">2</span>]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、向下调整法"><a href="#2、向下调整法" class="headerlink" title="2、向下调整法"></a>2、向下调整法</h3><p>向下调整法是从上向下调，该方法在建堆，解决排序等问题上有重大作用，所以应当重点掌握。对于采用向下调整法来说，应该满足条件：该根节点左右子树均为大堆或者均为小堆，只有根节点不满足，这时候我们采用向下调整法来将整个树调整成堆。具体做法如下（以小根堆为例）：<br><strong>从根节点开始，比较该节点与其左右孩子节点的值，如果该节点的值大于孩子节点的值，将其与左右孩子中较小的那个进行交换，一直到该节点为最后一层或者该节点的值小于等于左右孩子节点的值时结束。</strong><br><img src="https://s2.loli.net/2023/10/07/25mYzOR7TAHBbrD.png" alt="向下调整法.png"></p>
<p>代码实现思路：从根节点，左右孩子节点中比较出最大的那个，如果最大的那个节点是孩子节点，则将根节点与孩子节点进行交换，假设根节点小标为u，则左孩子节点下标为2u,右孩子节点下标为2u + 1,假设节点数为my_size，则代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个变量t来表示最大值下标</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有左孩子，并且左孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果父亲有右孩子，并且右孩子为最小值。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= my_size &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、堆的一些操作"><a href="#三、堆的一些操作" class="headerlink" title="三、堆的一些操作"></a>三、堆的一些操作</h2><p><strong>1、插入一个数</strong><br>该操作其实就是向上调整法的应用，将该数插入到数组末尾，然后进行向上调整操作即可。  </p>
<blockquote>
<p>heap[my_size++] &#x3D; x; up(my_size);  </p>
</blockquote>
<p><strong>2、求集合当中的最值</strong><br>直接返回堆顶元素即可。</p>
<blockquote>
<p>return h[1];  </p>
</blockquote>
<p><strong>3、删除集合中的最值</strong><br>删除集合中的最值我们采用覆盖的方法，即将最后一个节点的值覆盖到根节点的值，再将my_size–,然后对新的根节点进行向下调整操作即可。为什么要这么做呢？<strong>因为我们使用数组储存的堆结构，而删除第一个元素的话，后面的元素都会进行改变且结构被破坏，比较麻烦。而如果我们用最后一个元素去覆盖的话，前面的其他元素不需要进行改变且维持原有堆结构保持不变（除了新覆盖的根节点不满足），我们只需要将根节点down()操作一下即可，非常方便。</strong><br><img src="https://s2.loli.net/2023/10/07/WVLJAjKUk6vMzql.png" alt="删除集合中的最值.png"></p>
<blockquote>
<p>heap[1] &#x3D; heap[my_size–]; down(1);  </p>
</blockquote>
<p><strong>4、删除任意一个元素</strong><br>删除任意一个元素，假设删除第k个元素，则需要将末尾元素覆盖第k个元素，然后将,my_size–，然后得分情况（以小跟堆为例），如果是变大的话，需要down()一下，如果是是变小的话，需要down()一下，这里我们直接将两个都写，因为这里两个中只会执行一个。</p>
<blockquote>
<p>heap[k] &#x3D; heap[my_size–]; up(k); down(k);  </p>
</blockquote>
<p><strong>5、修改任意一个元素</strong><br>修改任意一个元素与前面同理。</p>
<blockquote>
<p>heap[k] &#x3D; x; down(k); up(k);</p>
</blockquote>
<h2 id="四、堆排序、TopK问题"><a href="#四、堆排序、TopK问题" class="headerlink" title="四、堆排序、TopK问题"></a>四、堆排序、TopK问题</h2><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>知道了堆的基本性质和操作，那给定一个无序数组如何将其建成大堆呢？我们可以用向上调整法和向下调整法。这里我们采用<strong>向下调整法建堆，因为其时间复杂度优于一个一个插入的向上调整法（时间复杂度为O（NlogN）。用向下调整法建堆的时间复杂度为O（N）</strong>，具体建堆过程分析如下：<br>我们从最后一个非叶子结点开始递归向上进行down操作（叶结点自然不用调整），假设总共有n个节点,则最后一个非叶子节点下标为n &#x2F; 2，则我们从n &#x2F; 2处开始进行向下调整即可。<br><img src="https://s2.loli.net/2023/10/07/8IicoWXypqMbSrx.png" alt="建堆过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">    <span class="built_in">down</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向下调整时间复杂度分析</strong>：<br>假设右n个节点，从倒数第二层开始，该层有n&#x2F;4个节点，每个节点需要调一次，倒数第三层，该层有n&#x2F;8个节点，每个节点需要调两次,依次类推，时间复杂度为：</p>
<blockquote>
<p>n&#x2F;4 * 1 + n&#x2F;8 * 2 + n&#x2F;16 * 3 + n&#x2F;32 * 4 +…<br>&#x3D; n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …)<br>令S &#x3D; 1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^5 + …<br>则2S &#x3D; 1&#x2F;2 + 2&#x2F;2^2 + 3&#x2F;2^3 + 4&#x2F;2^4 + …<br>2S - S &#x3D; S &#x3D;1&#x2F;2 + 2&#x2F;2^2 + 1&#x2F;2^3 + 1&#x2F;2^4 + … &lt; 1<br>则n(1&#x2F;2^2 + 2&#x2F;2^3 + 3&#x2F;2^4 + 4&#x2F;2^4 + …) &lt; n</p>
</blockquote>
<p>故时间复杂度小于N,进一步分析可知<strong>向下调整建堆的时间复杂度为O（N）</strong></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>我们来利用堆的性质来进行排序。如果要排升序或者降序，我们应该建大堆还是小堆呢？答案是<strong>排升序，建大堆；排降序，建小堆</strong>。原因是我们要在原数组上进行排序的话，以排升序为例，我们假如建小堆，那么每次的根节点将是当前最小值，而下一步的话最小值根节点为左孩子或者右孩子，这样继续排下去的话，整个堆的结构会被打乱，无法满足要求。而我们采用前面删除的思想，建大堆。每次只需将堆顶和堆底元素进行交换，然后对堆顶进行向下调整，每次都能将最大值放入后面正确的位置，且前面的堆结构维持不变。具体过程如下：<br><img src="https://s2.loli.net/2023/10/07/sL8AXGUB1kViafF.png" alt="堆排序过程.png"><br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(my_size &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">swap</span>(h[<span class="number">1</span>], h[my_size--]);</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序时间复杂度：向下调整N次，每次调整为O(logN),建堆为O(N)，则为O(N + NlogN),即为O(NlogN);</strong></p>
<h3 id="Topk问题"><a href="#Topk问题" class="headerlink" title="Topk问题"></a>Topk问题</h3><p>接下来我们来看一个经典问题：<span style="background-color: yellow;">Topk问题</span></p>
<p><strong>题目：输入一个长度为 n的整数数列，从小到大输出前 m小的数。</strong><br>此题我们可以用快排等排序来做，  今天我们用堆来做（堆在处理海量数据时具有重要应用）<br>思路：题目要求我们从小到大输出前m小的数,那么我们可以构造一个小根堆，每次取出堆顶元素即可。具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], MySize;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用t来表示三个点里最小值的编号</span></span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有左孩子，并且左孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果父亲有右孩子，并且右孩子小于父亲。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= MySize &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t= <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最小值变化了，说明需要调堆，则交换。</span></span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    MySize = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从n / 2，即最后一个孩子的父亲开始调。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i ; i--)&#123;</span><br><span class="line">        <span class="built_in">down</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        h[<span class="number">1</span>] = h[MySize--];</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>本篇文章主要介绍了堆的基本概念和性质</li>
<li>重点介绍了堆的两个基本操作：<strong>向上调整法(up)和向下调整法(down)</strong> ，向下调整法的应用较多，应当重点掌握。</li>
<li>接着我们介绍了基于up和down两种操作的一些堆能实现的操作，<strong>插入一个数、求集合中的最值、删除集合中的最值、删除任意一个元素、修改任意一个元素</strong> ，以及删除时的覆盖思想。</li>
<li>重点分析了建堆的过程：<strong>堆排序和Topk问题</strong>，了解了建堆的方法以及时间复杂度，<strong>一个一个元素插入+向上调整法建堆的时间复杂度是O(N*longN),而从最后一个非叶子节点开始递归向上进行向下调整法建堆的时间复杂度为O(N)</strong> 。</li>
<li>了解了堆的应用，堆排序、Topk问题，知道<strong>排升序，建大堆；排降序，建小堆</strong>。堆在Topk问题上重要应用，我们只需要关注前k个数。堆还有很多重要作用，海量数据时Topk的问题，外排序等内容。</li>
<li><span style="background-color: yellow;">一个元素要成为Topk，经历的过程可不简单，那么我们何尝不是如此？所以，加油吧，朋友。</span><blockquote>
<p>以上就是关于堆的入门的全部内容了，如果文章有什么错误或者遇到什么问题，欢迎随时和我交流联系。</p>
</blockquote>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>如何将两个很大的数进行相加？</title>
    <url>/2023/10/18/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0%E7%AE%97%E6%B3%95%E3%80%81%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h1 id="经典大数相加算法、高精度加法"><a href="#经典大数相加算法、高精度加法" class="headerlink" title="经典大数相加算法、高精度加法"></a>经典大数相加算法、高精度加法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><strong>先上一道题</strong>：<a href="https://leetcode.cn/problems/add-strings/"><strong>LC415.字符串相加</strong></a>     </p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<hr>
<p>对于这道题，可能很多朋友会想到将两个字符转为数字，然后将其进行相加，最后将结果再转为字符串。这种方式可行，但是如果数字非常大呢？大到连long long 都不够加呢?那我们就得请出我们的主角：<strong>高精度加法</strong>。  </p>
<span id="more"></span>
<h2 id="高精度加法是什么？"><a href="#高精度加法是什么？" class="headerlink" title="高精度加法是什么？"></a>高精度加法是什么？</h2><p>百科上的定义：高精度加法是信息学的一种重要算法。这种算法使用多个存储单位进行计算，因此它的计算范围超过一般使用一个存储单位的算法。所谓高精度加法，其实就是<strong>竖式加法</strong>，竖式加法我们在小学2年半的时候都学过，例如我要实现114 + 514，那就是：<br><img src="https://s2.loli.net/2023/10/18/2DF5GTCgQUMhOHW.png" alt="竖式加法.jpg">   </p>
<p>如上图所示，我们从个位开始相加，4 + 4 &#x3D; 8，然后到十位，1 + 1 &#x3D; 2，接着到百位，1 + 5 &#x3D; 6，所得结果就是628。所示例子没有进位，如果有进位的话，需要加上进位值。如9 + 3，需要进1，本位是2。</p>
<h2 id="为什么需要高精度加法？"><a href="#为什么需要高精度加法？" class="headerlink" title="为什么需要高精度加法？"></a>为什么需要高精度加法？</h2><p>高精度加法原来就是所谓的竖式相加，这不是小学生都会吗？其实，高精度加法在计算机算法中有着重要的应用。我们知道,在C&#x2F;C++语言中，通常来说（32位机器）,**int、long类型占32位，long long类型占64位，而最大的类型unsigned long long能表示的最大数也就才(1e19+8e18)**，如果要几百位的数来进行相加，那就不行了，所以，我们就可以使用高精度来计算，高精度一般也会用来处理大数相加的问题。</p>
<h2 id="高精度加法实现（C-）"><a href="#高精度加法实现（C-）" class="headerlink" title="高精度加法实现（C++）"></a>高精度加法实现（C++）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们将两个大数采用字符串的形式输入，然后模拟竖式加法的过程，<strong>用两个指针，先从个位开始相加（即字符串的最后一位），我们定义一个变量add来存进位值（如果没有进位则为0），然后逐步往高位移动，继续相加。考虑到两个数位数会有不一样的情况，有一个先加完，一个后加完，那我们采取将先加完的数的剩余位默认补0的方式即可</strong>，具体代码实现如下。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">class Solution &#123;
public:
    string addStrings(string num1, string num2) &#123;
        //从个位开始相加，初始化进位add为0
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        string ans = &quot;&quot;;//定义一个空字符串来拼接答案
        
        //当其中一个数没加完或者进位大于0时执行循环
        while(i &gt;= 0 || j &gt;= 0 || add &gt; 0)&#123;
            //当前位数没有加完则为本身，加完的话则默认为补的0
            int x = i &gt;= 0 ? num1[i] - &#39;0&#39; : 0;
            int y = j &gt;= 0 ? num2[j] - &#39;0&#39; : 0;
            int result = x + y + add;
            
            //将当前位的值加入ans
            ans.push_back(&#39;0&#39; + result % 10);
            
            //更新进位值
            add = result / 10;
            i--;
            j--;
        &#125;
        
        //由于每一位插入时是尾插导致低位在前，翻转一下即可
        reverse(ans.begin(), ans.end());
        return ans;
    &#125;
&#125;;
</code></pre>
<ul>
<li>时间复杂度：O(max(len1, len2))，其中len1和len2分别为两字符串的长度。  </li>
<li>空间复杂度：O(1)，我们只需要常数空间来存储若干变量。</li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://leetcode.cn/problems/add-binary/"><strong>LC67.二进制求和</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers/"><strong>LC2.两数相加</strong></a>    </p>
<p><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/"><strong>LC445.两数相加II</strong></a>    </p>
<hr>
<p>这里我们研究一下两数相加这题，题目如下：  </p>
<p><strong>LC2.两数相加</strong><br>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><img src="https://s2.loli.net/2023/10/18/OfD6LoA2caST81m.png" alt="add-two.png"></p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>如果仔细看完高精度加法的内容的话，会发现，这也不还是相当于模拟加法的过程吗?只是存储形式从字符串变为了链表而已。我们先<strong>把两链表头看成最低位即个位，开始进行相加，同样我们也用一个变量add来存储进位值，接着进行下一个节点的相加，一直到链表为空,同样也是会有一个链表先走完的情况，那我们将先走完的剩下的空位补0即可</strong>。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="cpp">class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        //创建头指针和尾指针
        ListNode* head = nullptr, *tail = nullptr;
        
        //定义变量表示进位值，初始化为0
        int add = 0;
    
        //当其中一个链表不为空时或者进位值不为0时进行循环
        while(l1 || l2 || add &gt; 0)&#123;
            int x = l1 ? l1 -&gt; val : 0;
            int y = l2 ? l2 -&gt; val : 0;
            int sum = x + y + add;
            
            //创建一个节点来存储相加后当前位的值
            ListNode* tmp = new ListNode(sum % 10);
            if(!head)&#123;
                head = tail = tmp;
            &#125; else &#123;
                tail -&gt; next = tmp;
                tail = tail -&gt; next;//更新tail
            &#125;
            add = sum / 10;//更新进位值
            
            //迭代往下走
            if(l1) l1 = l1 -&gt; next;
            if(l2) l2 = l2 -&gt; next;
        &#125;
        return head;
    &#125;
&#125;;
</code></pre>
<h3 id="高精度计算"><a href="#高精度计算" class="headerlink" title="高精度计算"></a>高精度计算</h3><p>我们在上面入门学习了高精度加法，即模拟竖式计算，也通过字符串相加，两数相加等题目对其有了更深的理解。那其实，有<strong>高精度加法，当然也有高精度减法、高精度乘法、高精度除法</strong>，其实本质上都是在模拟我们竖式计算的过程。而这些高精度计算的方法，为我们计算大数提供了可行方式，今后我们也会逐渐地深入学习和了解。</p>
<blockquote>
<p>以上就是字符串相加、经典大数相加算法(高精度加法)入门的全部内容了，如果文章有什问题或者错误，或者有什么建议和想法，欢迎随时和我交流。</p>
</blockquote>
]]></content>
  </entry>
</search>
